Index: pw_grids.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/pw_grids.F,v
retrieving revision 1.118
diff -b -c -3 -r1.118 pw_grids.F
*** pw_grids.F	25 Feb 2011 12:48:36 -0000	1.118
--- pw_grids.F	22 Apr 2011 18:01:42 -0000
***************
*** 1112,1120 ****
--- 1112,1125 ----
                                                  j1, j2
      INTEGER, ALLOCATABLE, DIMENSION(:)       :: cindex, icol, irow, rindex
      LOGICAL                                  :: failure
+ !NB load balance
+     INTEGER                                  :: im, ic, jc, ii, jj
  
  !------------------------------------------------------------------------------
  
+ #ifdef ORIGINAL_RAY_DISTRIBUTION
+ !NB original distribution, can have bad load balance in cp_ddapc_apply_CD which
+ !NB uses spherical cutoff even though overall grid is full and block distributed
      failure = .FALSE.
  
      i1 = SIZE ( yz_mask, 1 )
***************
*** 1155,1160 ****
--- 1160,1231 ----
      DEALLOCATE ( irow, rindex, icol, cindex, STAT = ierr )
      CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
  
+ #else
+ !NB spiral out from origin, so that even if overall grid is full and
+ !NB block distributed, spherical cutoff still leads to good load
+ !NB balance in cp_ddapc_apply_CD
+ 
+     i1 = SIZE ( yz_mask, 1 )
+     i2 = SIZE ( yz_mask, 2 )
+     yz_index = 0
+ 
+    icount = 1
+    ic=i1/2
+    jc=i2/2
+    ii=ic
+    jj=jc
+    if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+       if (yz_mask(ii,jj) /= 0) then
+ 	 yz_index(1,icount) = ii
+ 	 yz_index(2,icount) = jj
+ 	 icount = icount + 1
+       endif
+    endif
+    do im=1, max(ic+1,jc+1)
+       ii = ic-im
+       do jj=jc-im,jc+im
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       ii = ic+im
+       do jj=jc-im,jc+im
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       jj = jc-im
+       do ii=ic-im+1,ic+im-1
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       jj = jc+im
+       do ii=ic-im+1,ic+im-1
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+    end do
+ 
+ #endif
+ 
    END SUBROUTINE order_mask
  
  ! *****************************************************************************
Index: ewald_spline_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/ewald_spline_util.F,v
retrieving revision 1.28
diff -b -c -3 -r1.28 ewald_spline_util.F
*** ewald_spline_util.F	19 Apr 2011 06:28:35 -0000	1.28
--- ewald_spline_util.F	22 Apr 2011 18:01:42 -0000
***************
*** 152,159 ****
                                                  Term, xs1, xs2, xs3
      TYPE(pw_spline_precond_type), POINTER    :: precond
      TYPE(section_vals_type), POINTER         :: interp_section
! 
! !NB parallelization
  
      CALL timeset(routineN,handle)
      n1  = grid%pw_grid%npts(1)
--- 152,163 ----
                                                  Term, xs1, xs2, xs3
      TYPE(pw_spline_precond_type), POINTER    :: precond
      TYPE(section_vals_type), POINTER         :: interp_section
!     !NB pull expensive Cos() out of inner looop
!     REAL(KIND=dp), allocatable               :: cos_gx(:,:), cos_gy(:,:), cos_gz(:,:)
!     REAL(KIND=dp), allocatable               :: sin_gx(:,:), sin_gy(:,:), sin_gz(:,:)
!     REAL(KIND=dp)                            :: cos_gy_gz, sin_gy_gz
!     INTEGER                                  :: iLg, stat
!     LOGICAL                                  :: failure
  
      CALL timeset(routineN,handle)
      n1  = grid%pw_grid%npts(1)
***************
*** 177,182 ****
--- 181,222 ----
      ! Used the full symmetry to reduce the evaluation to 1/64th
      !NB parallelization
      iii = 0
+      !NB allocate temporaries for Cos refactoring
+      ALLOCATE(cos_gx(size(Lg),gbo(1,1):gbo(2,1)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gx(size(Lg),gbo(1,1):gbo(2,1)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(cos_gy(size(Lg),gbo(1,2):gbo(2,2)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gy(size(Lg),gbo(1,2):gbo(2,2)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(cos_gz(size(Lg),gbo(1,3):gbo(2,3)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gz(size(Lg),gbo(1,3):gbo(2,3)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      !NB precalculate Cos(gx*xs1) etc for Cos refactoring
+      DO k=gbo(1,3), gbo(2,3)
+        my_k  = k-gbo(1,3)
+        xs3   = REAL(my_k,dp)*dr3
+        IF (k > nzlim ) CYCLE
+        cos_gz(1:size(Lg),k) = Cos(gz(1:size(Lg))*xs3)
+        sin_gz(1:size(Lg),k) = Sin(gz(1:size(Lg))*xs3)
+      END DO ! k
+      xs2   = 0.0_dp
+      DO j  =  gbo(1,2), gbo(2,2)
+        IF (j > nylim ) CYCLE
+        cos_gy(1:size(Lg),j) = Cos(gy(1:size(Lg))*xs2)
+        sin_gy(1:size(Lg),j) = Sin(gy(1:size(Lg))*xs2)
+        xs2 = xs2 + dr2
+      END DO ! j
+      xs1   = 0.0_dp
+      DO i  =  gbo(1,1), gbo(2,1)
+        IF (i > nxlim ) CYCLE
+        cos_gx(1:size(Lg),i) = Cos(gx(1:size(Lg))*xs1)
+        sin_gx(1:size(Lg),i) = Sin(gx(1:size(Lg))*xs1)
+        xs1 = xs1 + dr1
+     END DO ! i
+ 
      LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
         my_k  = k-gbo(1,3)
         xs3   = REAL(my_k,dp)*dr3
***************
*** 193,207 ****
                 Term  = 0.0_dp
                 ! Sum over k vectors
                 DO kg = 1, SIZE(Lg)
!                   Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
                 END DO
                 grid%cr3d(i,j,k) = Term
               ENDIF
               xs1 = xs1 + dr1
!           END DO
            xs2 = xs2 + dr2
!        END DO
      END DO LoopOnGrid
      !NB parallelization
      CALL mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
  
--- 233,264 ----
                 Term  = 0.0_dp
                 ! Sum over k vectors
                 DO kg = 1, SIZE(Lg)
!                   !NB Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
! 		  ! cos(A+B) = cos A cos B âˆ’ sin A sin B
! 		  cos_gy_gz = cos_gy(kg,j)*cos_gz(kg,k) - sin_gy(kg,j)*sin_gz(kg,k)
! 		  sin_gy_gz = cos_gy(kg,j)*sin_gz(kg,k) + sin_gy(kg,j)*cos_gz(kg,k)
! 		  Term = Term + lg(kg)*(cos_gx(kg,i)*cos_gy_gz - sin_gx(kg,i)*sin_gy_gz)
                 END DO
                 grid%cr3d(i,j,k) = Term
               ENDIF
               xs1 = xs1 + dr1
!           END DO ! i
            xs2 = xs2 + dr2
!        END DO ! j
      END DO LoopOnGrid
+     !NB deallocate temporaries for Cos refactoring
+     DEALLOCATE(cos_gx,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gx,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(cos_gy,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gy,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(cos_gz,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gz,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
      !NB parallelization
      CALL mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
  
Index: ../src/cp_ddapc_methods.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_methods.F,v
retrieving revision 1.43
diff -b -c -3 -r1.43 cp_ddapc_methods.F
*** cp_ddapc_methods.F	19 Apr 2011 06:28:35 -0000	1.43
--- cp_ddapc_methods.F	28 Apr 2011 21:55:12 -0000
***************
*** 200,208 ****
      INTEGER :: e_dim, handle, idim1, idim2, ig, igauss1, igauss2, igmax, &
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
!     REAL(KIND=dp)                            :: g2, gcut2, rvec1(3), &
!                                                 rvec2(3), rvec_diff(3), tmp
      REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: my_Am, my_Amw
  
      failure = .FALSE.
  
--- 200,209 ----
      INTEGER :: e_dim, handle, idim1, idim2, ig, igauss1, igauss2, igmax, &
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
!     REAL(KIND=dp)                            :: g2, gcut2, tmp
      REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: my_Am, my_Amw
+     !NB precalculate as many things outside of the innermost loop as possible, in particular w(ig)*gfunc(ig,igauus1)*gfunc(ig,igauss2)
+     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:,:,:) :: gfunc_sq(:,:,:)
  
      failure = .FALSE.
  
***************
*** 221,234 ****
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DO iparticle1 = 1, SIZE(particle_set)
-           rvec1=particle_set(iparticle1)%r
            DO iparticle2 = iparticle1, SIZE(particle_set)
-              rvec2=particle_set(iparticle2)%r
-              rvec_diff=rvec1-rvec2
               DO ig = s_dim, igmax
                  !NB replace explicit dot product and cosine with cos(A+B) formula - much faster
!                 my_Am(ig) = w(ig)*(g_dot_rvec_cos(ig-s_dim+1,iparticle1)*g_dot_rvec_cos(ig-s_dim+1,iparticle2) + &
                                     g_dot_rvec_sin(ig-s_dim+1,iparticle1)*g_dot_rvec_sin(ig-s_dim+1,iparticle2))
               END DO
               DO igauss1 = 1, SIZE(radii)
--- 222,241 ----
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+        ALLOCATE(gfunc_sq(s_dim:igmax,SIZE(radii),SIZE(radii)),stat=stat)
+        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+ 
+        DO igauss1 = 1, SIZE(radii)
+ 	  DO igauss2 = 1, SIZE(radii)
+ 	     gfunc_sq(s_dim:igmax,igauss1,igauss2) = w(s_dim:igmax)*gfunc(s_dim:igmax,igauss1)*gfunc(s_dim:igmax,igauss2)
+ 	  END DO
+        END DO
+ 
         DO iparticle1 = 1, SIZE(particle_set)
            DO iparticle2 = iparticle1, SIZE(particle_set)
               DO ig = s_dim, igmax
                  !NB replace explicit dot product and cosine with cos(A+B) formula - much faster
!                 my_Am(ig) = (g_dot_rvec_cos(ig-s_dim+1,iparticle1)*g_dot_rvec_cos(ig-s_dim+1,iparticle2) + &
                               g_dot_rvec_sin(ig-s_dim+1,iparticle1)*g_dot_rvec_sin(ig-s_dim+1,iparticle2))
               END DO
               DO igauss1 = 1, SIZE(radii)
***************
*** 237,245 ****
                  IF (iparticle2==iparticle1) istart_g = igauss1
                  DO igauss2 = istart_g, SIZE(radii)
                     idim2 = (iparticle2-1)*SIZE(radii)+igauss2
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) = my_Am(ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
  !NB no loss of accuracy in my test cases
  #ifdef ACCURATE_SUMS
                     tmp = accurate_sum(my_Amw)
--- 244,250 ----
                  IF (iparticle2==iparticle1) istart_g = igauss1
                  DO igauss2 = istart_g, SIZE(radii)
                     idim2 = (iparticle2-1)*SIZE(radii)+igauss2
! 		   my_Amw(s_dim:igmax) = my_Am(s_dim:igmax)*gfunc_sq(s_dim:igmax,igauss1,igauss2)
  !NB no loss of accuracy in my test cases
  #ifdef ACCURATE_SUMS
                     tmp = accurate_sum(my_Amw)
***************
*** 252,257 ****
--- 257,264 ----
               END DO
            END DO
         END DO
+        DEALLOCATE(gfunc_sq,stat=stat)
+        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DEALLOCATE(my_Amw,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DEALLOCATE(my_Am,stat=stat)
***************
*** 373,384 ****
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
      REAL(KIND=dp)                            :: factor, g2, gcut2, tmp
!     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: arg1_v_sin, my_Amw
!     REAL(KIND=dp), ALLOCATABLE, &
!       DIMENSION(:, :)                        :: my_Am
!     REAL(KIND=dp), DIMENSION(3)              :: rvec1, rvec2, rvec_diff
! 
! !NB temporary for precomputing expensive sin()
  
      failure = .FALSE.
      CALL timeset(routineN,handle)
--- 380,390 ----
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
      REAL(KIND=dp)                            :: factor, g2, gcut2, tmp
!     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: arg1_v_sin
!     !NB Use DGEMM to speed up calculation, can't do accurate_sum() anymore because dgemm does the sum over g
!     EXTERNAL DGEMM
!     REAL(KIND=dp), ALLOCATABLE :: lhs(:,:), rhs(:,:)
!     INTEGER :: Nr, Np, Ng, icomp
  
      failure = .FALSE.
      CALL timeset(routineN,handle)
***************
*** 392,470 ****
            IF (g2 > gcut2) EXIT
            igmax  = ig
         ENDDO
-        ALLOCATE(my_Am(3,s_dim:igmax),stat=stat)
-        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
-        ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
-        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(arg1_v_sin(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  
!        DO iparticle1 = 1, SIZE(particle_set)
!           rvec1 =  particle_set(iparticle1)%r
!           DO iparticle2 = iparticle1, SIZE(particle_set)
!              rvec2 =  particle_set(iparticle2)%r
!              IF ((iparticle1 /= iparticle0).AND.(iparticle2 /= iparticle0)) CYCLE
!              IF    ((iparticle1 == iparticle0).AND.(iparticle2==iparticle0))  THEN
!                    factor=2.0_dp
!              ELSEIF (iparticle1 == iparticle0) THEN
!                    factor=1.0_dp
!              ELSEIF (iparticle2 == iparticle0) THEN
!                    factor=-1.0_dp
!              END IF
!              rvec_diff=rvec2-rvec1
! 
!              !NB precompute sin(g.(r1-r2)) with sin(A+B) formula - perhaps just move this into the loop?
!              arg1_v_sin(s_dim:igmax) = g_dot_rvec_sin(1:igmax-s_dim+1, iparticle2)*g_dot_rvec_cos(1:igmax-s_dim+1, iparticle1) - &
!                                        g_dot_rvec_cos(1:igmax-s_dim+1, iparticle2)*g_dot_rvec_sin(1:igmax-s_dim+1, iparticle1)
!              DO ig = s_dim, igmax
!                 my_Am(1:3,ig) = factor * w(ig) * arg1_v_sin(ig) * rho_tot_g%pw_grid%g(:,ig)
!              END DO
!              DO igauss1 = 1, SIZE(radii)
!                 idim1 = (iparticle1-1)*SIZE(radii)+igauss1
!                 istart_g = 1
!                 IF (iparticle2==iparticle1) istart_g = igauss1
!                 DO igauss2 = istart_g, SIZE(radii)
!                    idim2 = (iparticle2-1)*SIZE(radii)+igauss2
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(1,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,1) = tmp
!                    dAm (idim2,idim1,1) = tmp
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(2,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,2) = tmp
!                    dAm (idim2,idim1,2) = tmp
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(3,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,3) = tmp
!                    dAm (idim2,idim1,3) = tmp
!                 END DO
!              END DO
!           END DO
!        END DO
!        DEALLOCATE(my_Amw,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        DEALLOCATE(my_Am,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         !!! DEALLOCATE(arg1_v,stat=stat)
         !!! CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
--- 398,455 ----
            IF (g2 > gcut2) EXIT
            igmax  = ig
         ENDDO
         ALLOCATE(arg1_v_sin(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  
! ! want dAm(idim1 = (iparticle0-1)*SIZE(radii)+1:(iparticle0-1)*SIZE(radii)+size(radii),1:size(particle_set)*size(radii),1:3)
!        iparticle1 = iparticle0
!        Nr=SIZE(radii)
!        Np=SIZE(particle_set)
!        Ng=igmax-s_dim+1
!        allocate(lhs(Nr,Ng), stat=stat)
!        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        allocate(rhs(Ng,Np*Nr), stat=stat)
!        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
! 
! 	! fill in RHS
!        do iparticle2=1,Np
! !!	  IF    ((iparticle1 == iparticle0).AND.(iparticle2==iparticle0))  THEN
! !!		factor = 2.0_dp
! !!	  ELSEIF (iparticle1 == iparticle0) THEN
! !!		factor = 1.0_dp
! !!	  ELSEIF (iparticle2 == iparticle0) THEN
! !!		factor = -1.0_dp
! !!	  END IF
! 	  arg1_v_sin(s_dim:igmax) = g_dot_rvec_sin(1:Ng, iparticle2)*g_dot_rvec_cos(1:Ng, iparticle1) - &
! 				    g_dot_rvec_cos(1:Ng, iparticle2)*g_dot_rvec_sin(1:Ng, iparticle1)
! 	  do igauss2=1,Nr
! 	     !! rhs(1:Ng,(iparticle2-1)*Nr+igauss2) = factor*arg1_v_sin(s_dim:igmax)*gfunc(s_dim:igmax,igauss2)
! 	     rhs(1:Ng,(iparticle2-1)*Nr+igauss2) = arg1_v_sin(s_dim:igmax)*gfunc(s_dim:igmax,igauss2)
! 	  end do
!        end do
!        rhs(1:Ng,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr) = 2.0D0*rhs(1:Ng,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr)
! 
!        do icomp=1,3
! 	  ! fill in LHS
! 	  do ig=s_dim,igmax
! 	     lhs(1:Nr,ig-s_dim+1) = w(ig) * rho_tot_g%pw_grid%g(icomp,ig) * gfunc(ig,1:Nr)
! 	  end do
! 	  call DGEMM('N', 'N', Nr, Np*Nr, Ng, 1.0D0, lhs, Nr, rhs, Ng, 0.0D0, dAm((iparticle1-1)*Nr+1,1,icomp), Np*Nr)
!        end do ! icomp
! 
!        if (iparticle0 > 1) then
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,1))
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,2) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,2))
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,3) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,3))
!        endif
!        if (iparticle0 < Np) then
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,1))
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,2) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,2))
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,3) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,3))
!        endif
!        DEALLOCATE(rhs,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        DEALLOCATE(lhs,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         !!! DEALLOCATE(arg1_v,stat=stat)
         !!! CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
***************
*** 612,618 ****
            DEALLOCATE(AmE, stat=stat)
            CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         END IF
!        CALL invert_matrix(Am, AmI, inv_error, "N",error=error)
         IF (iw>0) THEN
            WRITE(iw,'(T3,A,F15.9)')" Error inverting the A matrix: ", inv_error
         END IF
--- 597,603 ----
            DEALLOCATE(AmE, stat=stat)
            CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         END IF
!        CALL invert_matrix(Am, AmI, inv_error, "N",error=error, improve=.false.)
         IF (iw>0) THEN
            WRITE(iw,'(T3,A,F15.9)')" Error inverting the A matrix: ", inv_error
         END IF
