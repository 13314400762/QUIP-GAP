Index: cp_ddapc_methods.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_methods.F,v
retrieving revision 1.41
diff -u -r1.41 cp_ddapc_methods.F
--- cp_ddapc_methods.F	8 Apr 2010 19:18:04 -0000	1.41
+++ cp_ddapc_methods.F	21 Apr 2010 20:17:22 -0000
@@ -506,7 +506,8 @@
           DEALLOCATE(AmE, stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
        END IF
-       CALL invert_matrix(Am, AmI, inv_error, "N",error=error)
+       !!NB speedup
+       CALL invert_matrix(Am, AmI, inv_error, "N",error=error, improve=.false.)
        IF (iw>0) THEN
           WRITE(iw,'(T3,A,F15.9)')" Error inverting the A matrix: ", inv_error
        END IF
Index: cp_ddapc_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_util.F,v
retrieving revision 1.23
diff -u -r1.23 cp_ddapc_util.F
--- cp_ddapc_util.F	3 Jan 2010 23:41:26 -0000	1.23
+++ cp_ddapc_util.F	21 Apr 2010 20:17:22 -0000
@@ -238,6 +238,9 @@
     TYPE(pw_type), POINTER                   :: rho_tot_g
     TYPE(qs_charges_type), POINTER           :: qs_charges
     TYPE(qs_rho_type), POINTER               :: rho
+    !!NB speed
+    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: cvT_AmI, AmI_cv, cvT_AmI_dAmj
+    !!
 
     CALL timeset(routineN,handle)
     failure         = .FALSE.
@@ -399,13 +402,23 @@
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           ALLOCATE(dqv(ndim,SIZE(particle_set),3), stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)     
+	  !!NB speed
+	  ALLOCATE(cvT_AmI(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(cvT_AmI_dAmj(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(AmI_cv(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  cvT_AmI = MATMUL(cv, cp_ddapc_env%AmI)
+	  AmI_cv = MATMUL(cp_ddapc_env%AmI,cv)
+	  !!
           !
           DO iparticle = 1, SIZE(particle_set)
              dAm = 0.0_dp
              dbv = 0.0_dp
              CALL build_der_b_vector(dbv, cp_ddapc_env%gfunc, cp_ddapc_env%w,&
                   particle_set, radii, rho_tot_g, gcut, iparticle, error);  dbv = dbv / Vol
-             CALL mp_sum(dbv,rho_tot_g%pw_grid%para%group)
+!! NB parallelization            CALL mp_sum(dbv,rho_tot_g%pw_grid%para%group)
              IF (debug_this_module) THEN
                 CALL debug_der_b_vector(dbv, particle_set, radii, rho_tot_g,&
                      gcut, iparticle, Vol, qs_env, error)
@@ -413,23 +426,33 @@
              END IF
              CALL build_der_A_matrix(dAm, cp_ddapc_env%gfunc, cp_ddapc_env%w,&
                   particle_set, radii, rho_tot_g, gcut, iparticle, error);  dAm = dAm /(Vol*Vol)
-             CALL mp_sum(dAm,rho_tot_g%pw_grid%para%group)             
+!! NB parallelization            CALL mp_sum(dAm,rho_tot_g%pw_grid%para%group)             
              IF (debug_this_module) THEN
                 CALL debug_der_A_matrix(dAm, particle_set, radii, rho_tot_g,&
                      gcut, iparticle, Vol, qs_env, error)
                 cp_ddapc_env => qs_env%cp_ddapc_env 
              END IF
              DO j = 1, 3
+		!!NB speed
+		cvT_AmI_dAmj = MATMUL(cvT_AmI, dAm(:,:,j))
                 dqv0 = - MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),-qv))
-                c3 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,bv)))) + &
-                       DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,dbv(:,j))) 
+		c3 = - DOT_PRODUCT(cvT_AmI_dAmj,MATMUL(cp_ddapc_env%AmI,bv)) + DOT_PRODUCT(cvT_AmI, dbv(:,j))
                 c3   = c3 / cp_ddapc_env%c0
-                c4 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,cv)))) / &
-                     cp_ddapc_env%c0
-                dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - &
-                     c3 * MATMUL(cp_ddapc_env%AmI,cv) + c4 * c1 * MATMUL(cp_ddapc_env%AmI,cv))
+		c4 = - DOT_PRODUCT(cvT_AmI_dAmj,AmI_cv) / cp_ddapc_env%c0
+		dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - (c3 - c4*c1) * AmI_cv)
+                ! dqv0 = - MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),-qv))
+                ! c3 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,bv)))) + &
+                       ! DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,dbv(:,j))) 
+                ! c3   = c3 / cp_ddapc_env%c0
+                ! c4 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,cv)))) / &
+                     ! cp_ddapc_env%c0
+                ! dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - &
+                     ! c3 * MATMUL(cp_ddapc_env%AmI,cv) + c4 * c1 * MATMUL(cp_ddapc_env%AmI,cv))
              END DO
           END DO
+	  !! NB parallelization
+          CALL mp_sum(dqv,rho_tot_g%pw_grid%para%group)             
+	  !!
           CPPostcondition(PRESENT(dq_out),cp_failure_level,routineP,error,failure)
           IF (.NOT.ASSOCIATED(dq_out)) THEN
              ALLOCATE(dq_out(SIZE(dqv,1),SIZE(dqv,2),SIZE(dqv,3)), stat=stat)
@@ -452,6 +475,12 @@
           DEALLOCATE(dAm, stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           DEALLOCATE(dbv, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(cvT_AmI, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(cvT_AmI_dAmj, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(AmI_cv, stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           CALL timestop(handle3)
        END IF
Index: ewald_spline_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/ewald_spline_util.F,v
retrieving revision 1.26
diff -u -r1.26 ewald_spline_util.F
--- ewald_spline_util.F	3 Jan 2010 23:41:27 -0000	1.26
+++ ewald_spline_util.F	21 Apr 2010 20:17:22 -0000
@@ -41,6 +41,9 @@
                                              pw_type
   USE timings,                         ONLY: timeset,&
                                              timestop
+  !! NB parallelization
+  USE message_passing,                 ONLY: mp_sum
+  !!
 #include "cp_common_uses.h"
 
   IMPLICIT NONE
@@ -150,6 +153,9 @@
                                                 Term, xs1, xs2, xs3
     TYPE(pw_spline_precond_type), POINTER    :: precond
     TYPE(section_vals_type), POINTER         :: interp_section
+    !! NB parallelization
+    integer :: iii
+    !!
 
     CALL timeset(routineN,handle)
     n1  = grid%pw_grid%npts(1)
@@ -171,6 +177,9 @@
     CALL pw_zero(grid, error=error)
 
     ! Used the full symmetry to reduce the evaluation to 1/64th
+    !! NB parallelization
+    iii = 0
+    !!
     LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
        my_k  = k-gbo(1,3)
        xs3   = REAL(my_k,dp)*dr3
@@ -181,17 +190,25 @@
           xs1   = 0.0_dp
           DO i  =  gbo(1,1), gbo(2,1)
              IF (i > nxlim ) CYCLE
-             Term  = 0.0_dp
-             ! Sum over k vectors
-             DO kg = 1, SIZE(Lg)
-                Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
-             END DO
-             grid%cr3d(i,j,k) = Term
+	     !! NB parallelization
+	     iii = iii + 1
+	     IF (mod(iii,grid%pw_grid%para%group_size) == grid%pw_grid%para%my_pos) THEN
+	       Term  = 0.0_dp
+	       ! Sum over k vectors
+	       DO kg = 1, SIZE(Lg)
+		  Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
+	       END DO
+	       grid%cr3d(i,j,k) = Term
+	     ENDIF
+	     !!
              xs1 = xs1 + dr1
           END DO
           xs2 = xs2 + dr2
        END DO
     END DO LoopOnGrid
+    !! NB parallelization
+    call mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
+    !!
 
     Fake_LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
        my_k = k
Index: mathlib.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/mathlib.F,v
retrieving revision 1.45
diff -u -r1.45 mathlib.F
--- mathlib.F	3 Jan 2010 23:41:36 -0000	1.45
+++ mathlib.F	21 Apr 2010 20:17:22 -0000
@@ -466,7 +466,7 @@
 !>       -            "T" => invert transpose(a)
 !> \version 1.0
 ! *****************************************************************************
-  SUBROUTINE invert_matrix_d(a,a_inverse,eval_error,option,error)
+  SUBROUTINE invert_matrix_d(a,a_inverse,eval_error,option,error,improve)
     REAL(KIND=dp), DIMENSION(:, :), &
       INTENT(IN)                             :: a
     REAL(KIND=dp), DIMENSION(:, :), &
@@ -474,6 +474,7 @@
     REAL(KIND=dp), INTENT(OUT)               :: eval_error
     CHARACTER(LEN=1), INTENT(IN), OPTIONAL   :: option
     TYPE(cp_error_type), INTENT(inout)       :: error
+    LOGICAL, INTENT(IN), OPTIONAL            :: improve
 
     CHARACTER(LEN=*), PARAMETER :: routineN = 'invert_matrix_d', &
       routineP = moduleN//':'//routineN
@@ -488,6 +489,7 @@
     REAL(KIND=dp), ALLOCATABLE, &
       DIMENSION(:, :)                        :: a_lu, b
     REAL(KIND=dp), EXTERNAL                  :: dlange
+    LOGICAL                                  :: do_improve
 
     EXTERNAL dgecon,dgerfs,dgetrf,dgetrs
 
@@ -500,6 +502,12 @@
       trans = "N"
     END IF
 
+    IF (PRESENT(improve)) THEN
+      do_improve = improve
+    ELSE
+      do_improve = .true.
+    ENDIF
+
     ! Get the dimension of matrix a
     n = SIZE(a,1)
 
@@ -596,22 +604,24 @@
 
     eval_error = 0.0_dp
 
-    DO iter=1,10
+    IF (do_improve) THEN
+      DO iter=1,10
 
-      CALL dgerfs(trans,n,n,a,n,a_lu,n,ipiv,b,n,a_inverse,n,ferr,berr,&
-                  work,iwork,info)
+	CALL dgerfs(trans,n,n,a,n,a_lu,n,ipiv,b,n,a_inverse,n,ferr,berr,&
+		    work,iwork,info)
 
-      IF (info /= 0) THEN
-        CALL stop_program(moduleN,routineN,__LINE__,&
-                          "Improving the computed solution in dgerfs failed")
-      END IF
+	IF (info /= 0) THEN
+	  CALL stop_program(moduleN,routineN,__LINE__,&
+			    "Improving the computed solution in dgerfs failed")
+	END IF
 
-      old_eval_error = eval_error
-      eval_error = MAXVAL(ferr)
+	old_eval_error = eval_error
+	eval_error = MAXVAL(ferr)
 
-      IF (ABS(eval_error - old_eval_error) <= EPSILON(1.0_dp)) EXIT
+	IF (ABS(eval_error - old_eval_error) <= EPSILON(1.0_dp)) EXIT
 
-    END DO
+      END DO
+    ENDIF
 
     ! Release work storage
     DEALLOCATE (work,STAT=stat)
