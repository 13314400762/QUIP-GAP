Index: pw_grids.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/pw_grids.F,v
retrieving revision 1.118
diff -b -c -3 -r1.118 pw_grids.F
*** pw_grids.F	25 Feb 2011 12:48:36 -0000	1.118
--- pw_grids.F	22 Apr 2011 18:01:42 -0000
***************
*** 1112,1120 ****
--- 1112,1125 ----
                                                  j1, j2
      INTEGER, ALLOCATABLE, DIMENSION(:)       :: cindex, icol, irow, rindex
      LOGICAL                                  :: failure
+ !NB load balance
+     INTEGER                                  :: im, ic, jc, ii, jj
  
  !------------------------------------------------------------------------------
  
+ #ifdef ORIGINAL_RAY_DISTRIBUTION
+ !NB original distribution, can have bad load balance in cp_ddapc_apply_CD which
+ !NB uses spherical cutoff even though overall grid is full and block distributed
      failure = .FALSE.
  
      i1 = SIZE ( yz_mask, 1 )
***************
*** 1155,1160 ****
--- 1160,1231 ----
      DEALLOCATE ( irow, rindex, icol, cindex, STAT = ierr )
      CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
  
+ #else
+ !NB spiral out from origin, so that even if overall grid is full and
+ !NB block distributed, spherical cutoff still leads to good load
+ !NB balance in cp_ddapc_apply_CD
+ 
+     i1 = SIZE ( yz_mask, 1 )
+     i2 = SIZE ( yz_mask, 2 )
+     yz_index = 0
+ 
+    icount = 1
+    ic=i1/2
+    jc=i2/2
+    ii=ic
+    jj=jc
+    if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+       if (yz_mask(ii,jj) /= 0) then
+ 	 yz_index(1,icount) = ii
+ 	 yz_index(2,icount) = jj
+ 	 icount = icount + 1
+       endif
+    endif
+    do im=1, max(ic+1,jc+1)
+       ii = ic-im
+       do jj=jc-im,jc+im
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       ii = ic+im
+       do jj=jc-im,jc+im
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       jj = jc-im
+       do ii=ic-im+1,ic+im-1
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+       jj = jc+im
+       do ii=ic-im+1,ic+im-1
+ 	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+ 	    if (yz_mask(ii,jj) /= 0) then
+ 	       yz_index(1,icount) = ii
+ 	       yz_index(2,icount) = jj
+ 	       icount = icount + 1
+ 	    endif
+ 	 endif
+       end do
+    end do
+ 
+ #endif
+ 
    END SUBROUTINE order_mask
  
  ! *****************************************************************************
Index: ewald_spline_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/ewald_spline_util.F,v
retrieving revision 1.28
diff -b -c -3 -r1.28 ewald_spline_util.F
*** ewald_spline_util.F	19 Apr 2011 06:28:35 -0000	1.28
--- ewald_spline_util.F	22 Apr 2011 18:01:42 -0000
***************
*** 152,159 ****
                                                  Term, xs1, xs2, xs3
      TYPE(pw_spline_precond_type), POINTER    :: precond
      TYPE(section_vals_type), POINTER         :: interp_section
! 
! !NB parallelization
  
      CALL timeset(routineN,handle)
      n1  = grid%pw_grid%npts(1)
--- 152,163 ----
                                                  Term, xs1, xs2, xs3
      TYPE(pw_spline_precond_type), POINTER    :: precond
      TYPE(section_vals_type), POINTER         :: interp_section
!     !NB pull expensive Cos() out of inner looop
!     REAL(KIND=dp), allocatable               :: cos_gx(:,:), cos_gy(:,:), cos_gz(:,:)
!     REAL(KIND=dp), allocatable               :: sin_gx(:,:), sin_gy(:,:), sin_gz(:,:)
!     REAL(KIND=dp)                            :: cos_gy_gz, sin_gy_gz
!     INTEGER                                  :: iLg, stat
!     LOGICAL                                  :: failure
  
      CALL timeset(routineN,handle)
      n1  = grid%pw_grid%npts(1)
***************
*** 177,182 ****
--- 181,222 ----
      ! Used the full symmetry to reduce the evaluation to 1/64th
      !NB parallelization
      iii = 0
+      !NB allocate temporaries for Cos refactoring
+      ALLOCATE(cos_gx(size(Lg),gbo(1,1):gbo(2,1)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gx(size(Lg),gbo(1,1):gbo(2,1)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(cos_gy(size(Lg),gbo(1,2):gbo(2,2)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gy(size(Lg),gbo(1,2):gbo(2,2)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(cos_gz(size(Lg),gbo(1,3):gbo(2,3)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      ALLOCATE(sin_gz(size(Lg),gbo(1,3):gbo(2,3)),stat=stat)
+      CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+      !NB precalculate Cos(gx*xs1) etc for Cos refactoring
+      DO k=gbo(1,3), gbo(2,3)
+        my_k  = k-gbo(1,3)
+        xs3   = REAL(my_k,dp)*dr3
+        IF (k > nzlim ) CYCLE
+        cos_gz(1:size(Lg),k) = Cos(gz(1:size(Lg))*xs3)
+        sin_gz(1:size(Lg),k) = Sin(gz(1:size(Lg))*xs3)
+      END DO ! k
+      xs2   = 0.0_dp
+      DO j  =  gbo(1,2), gbo(2,2)
+        IF (j > nylim ) CYCLE
+        cos_gy(1:size(Lg),j) = Cos(gy(1:size(Lg))*xs2)
+        sin_gy(1:size(Lg),j) = Sin(gy(1:size(Lg))*xs2)
+        xs2 = xs2 + dr2
+      END DO ! j
+      xs1   = 0.0_dp
+      DO i  =  gbo(1,1), gbo(2,1)
+        IF (i > nxlim ) CYCLE
+        cos_gx(1:size(Lg),i) = Cos(gx(1:size(Lg))*xs1)
+        sin_gx(1:size(Lg),i) = Sin(gx(1:size(Lg))*xs1)
+        xs1 = xs1 + dr1
+     END DO ! i
+ 
      LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
         my_k  = k-gbo(1,3)
         xs3   = REAL(my_k,dp)*dr3
***************
*** 193,207 ****
                 Term  = 0.0_dp
                 ! Sum over k vectors
                 DO kg = 1, SIZE(Lg)
!                   Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
                 END DO
                 grid%cr3d(i,j,k) = Term
               ENDIF
               xs1 = xs1 + dr1
!           END DO
            xs2 = xs2 + dr2
!        END DO
      END DO LoopOnGrid
      !NB parallelization
      CALL mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
  
--- 233,264 ----
                 Term  = 0.0_dp
                 ! Sum over k vectors
                 DO kg = 1, SIZE(Lg)
!                   !NB Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
! 		  ! cos(A+B) = cos A cos B âˆ’ sin A sin B
! 		  cos_gy_gz = cos_gy(kg,j)*cos_gz(kg,k) - sin_gy(kg,j)*sin_gz(kg,k)
! 		  sin_gy_gz = cos_gy(kg,j)*sin_gz(kg,k) + sin_gy(kg,j)*cos_gz(kg,k)
! 		  Term = Term + lg(kg)*(cos_gx(kg,i)*cos_gy_gz - sin_gx(kg,i)*sin_gy_gz)
                 END DO
                 grid%cr3d(i,j,k) = Term
               ENDIF
               xs1 = xs1 + dr1
!           END DO ! i
            xs2 = xs2 + dr2
!        END DO ! j
      END DO LoopOnGrid
+     !NB deallocate temporaries for Cos refactoring
+     DEALLOCATE(cos_gx,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gx,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(cos_gy,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gy,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(cos_gz,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+     DEALLOCATE(sin_gz,stat=stat)
+     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
      !NB parallelization
      CALL mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
  
Index: cp_ddapc_methods.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_methods.F,v
retrieving revision 1.44
diff -b -c -3 -r1.44 cp_ddapc_methods.F
*** cp_ddapc_methods.F	2 May 2011 10:50:56 -0000	1.44
--- cp_ddapc_methods.F	2 May 2011 14:37:33 -0000
***************
*** 200,208 ****
      INTEGER :: e_dim, handle, idim1, idim2, ig, igauss1, igauss2, igmax, &
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
!     REAL(KIND=dp)                            :: g2, gcut2, rvec1(3), &
!                                                 rvec2(3), rvec_diff(3), tmp
      REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: my_Am, my_Amw
  
      failure = .FALSE.
  
--- 200,209 ----
      INTEGER :: e_dim, handle, idim1, idim2, ig, igauss1, igauss2, igmax, &
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
!     REAL(KIND=dp)                            :: g2, gcut2, tmp
      REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: my_Am, my_Amw
+     !NB precalculate as many things outside of the innermost loop as possible, in particular w(ig)*gfunc(ig,igauus1)*gfunc(ig,igauss2)
+     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:,:,:) :: gfunc_sq(:,:,:)
  
      failure = .FALSE.
  
***************
*** 221,234 ****
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DO iparticle1 = 1, SIZE(particle_set)
-           rvec1=particle_set(iparticle1)%r
            DO iparticle2 = iparticle1, SIZE(particle_set)
-              rvec2=particle_set(iparticle2)%r
-              rvec_diff=rvec1-rvec2
               DO ig = s_dim, igmax
                  !NB replace explicit dot product and cosine with cos(A+B) formula - much faster
!                 my_Am(ig) = w(ig)*(g_dot_rvec_cos(ig-s_dim+1,iparticle1)*g_dot_rvec_cos(ig-s_dim+1,iparticle2) + &
                                     g_dot_rvec_sin(ig-s_dim+1,iparticle1)*g_dot_rvec_sin(ig-s_dim+1,iparticle2))
               END DO
               DO igauss1 = 1, SIZE(radii)
--- 222,241 ----
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+        ALLOCATE(gfunc_sq(s_dim:igmax,SIZE(radii),SIZE(radii)),stat=stat)
+        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+ 
+        DO igauss1 = 1, SIZE(radii)
+ 	  DO igauss2 = 1, SIZE(radii)
+ 	     gfunc_sq(s_dim:igmax,igauss1,igauss2) = w(s_dim:igmax)*gfunc(s_dim:igmax,igauss1)*gfunc(s_dim:igmax,igauss2)
+ 	  END DO
+        END DO
+ 
         DO iparticle1 = 1, SIZE(particle_set)
            DO iparticle2 = iparticle1, SIZE(particle_set)
               DO ig = s_dim, igmax
                  !NB replace explicit dot product and cosine with cos(A+B) formula - much faster
!                 my_Am(ig) = (g_dot_rvec_cos(ig-s_dim+1,iparticle1)*g_dot_rvec_cos(ig-s_dim+1,iparticle2) + &
                                     g_dot_rvec_sin(ig-s_dim+1,iparticle1)*g_dot_rvec_sin(ig-s_dim+1,iparticle2))
               END DO
               DO igauss1 = 1, SIZE(radii)
***************
*** 237,245 ****
                  IF (iparticle2==iparticle1) istart_g = igauss1
                  DO igauss2 = istart_g, SIZE(radii)
                     idim2 = (iparticle2-1)*SIZE(radii)+igauss2
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) = my_Am(ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
  !NB no loss of accuracy in my test cases
  #ifdef ACCURATE_SUMS
                     tmp = accurate_sum(my_Amw)
--- 244,250 ----
                  IF (iparticle2==iparticle1) istart_g = igauss1
                  DO igauss2 = istart_g, SIZE(radii)
                     idim2 = (iparticle2-1)*SIZE(radii)+igauss2
! 		   my_Amw(s_dim:igmax) = my_Am(s_dim:igmax)*gfunc_sq(s_dim:igmax,igauss1,igauss2)
  !NB no loss of accuracy in my test cases
  #ifdef ACCURATE_SUMS
                     tmp = accurate_sum(my_Amw)
***************
*** 252,257 ****
--- 257,264 ----
               END DO
            END DO
         END DO
+        DEALLOCATE(gfunc_sq,stat=stat)
+        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DEALLOCATE(my_Amw,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         DEALLOCATE(my_Am,stat=stat)
***************
*** 373,384 ****
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
      REAL(KIND=dp)                            :: factor, g2, gcut2, tmp
!     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: arg1_v_sin, my_Amw
!     REAL(KIND=dp), ALLOCATABLE, &
!       DIMENSION(:, :)                        :: my_Am
!     REAL(KIND=dp), DIMENSION(3)              :: rvec1, rvec2, rvec_diff
! 
! !NB temporary for precomputing expensive sin()
  
      failure = .FALSE.
      CALL timeset(routineN,handle)
--- 380,390 ----
        iparticle1, iparticle2, istart_g, s_dim, stat
      LOGICAL                                  :: failure
      REAL(KIND=dp)                            :: factor, g2, gcut2, tmp
!     REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: arg1_v_sin
!     !NB Use DGEMM to speed up calculation, can't do accurate_sum() anymore because dgemm does the sum over g
!     EXTERNAL DGEMM
!     REAL(KIND=dp), ALLOCATABLE :: lhs(:,:), rhs(:,:)
!     INTEGER :: Nr, Np, Ng, icomp
  
      failure = .FALSE.
      CALL timeset(routineN,handle)
***************
*** 392,470 ****
            IF (g2 > gcut2) EXIT
            igmax  = ig
         ENDDO
-        ALLOCATE(my_Am(3,s_dim:igmax),stat=stat)
-        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
-        ALLOCATE(my_Amw(s_dim:igmax),stat=stat)
-        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(arg1_v_sin(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  
!        DO iparticle1 = 1, SIZE(particle_set)
!           rvec1 =  particle_set(iparticle1)%r
!           DO iparticle2 = iparticle1, SIZE(particle_set)
!              rvec2 =  particle_set(iparticle2)%r
!              IF ((iparticle1 /= iparticle0).AND.(iparticle2 /= iparticle0)) CYCLE
!              IF    ((iparticle1 == iparticle0).AND.(iparticle2==iparticle0))  THEN
!                    factor=2.0_dp
!              ELSEIF (iparticle1 == iparticle0) THEN
!                    factor=1.0_dp
!              ELSEIF (iparticle2 == iparticle0) THEN
!                    factor=-1.0_dp
!              END IF
!              rvec_diff=rvec2-rvec1
! 
!              !NB precompute sin(g.(r1-r2)) with sin(A+B) formula - perhaps just move this into the loop?
!              arg1_v_sin(s_dim:igmax) = g_dot_rvec_sin(1:igmax-s_dim+1, iparticle2)*g_dot_rvec_cos(1:igmax-s_dim+1, iparticle1) - &
!                                        g_dot_rvec_cos(1:igmax-s_dim+1, iparticle2)*g_dot_rvec_sin(1:igmax-s_dim+1, iparticle1)
!              DO ig = s_dim, igmax
!                 my_Am(1:3,ig) = factor * w(ig) * arg1_v_sin(ig) * rho_tot_g%pw_grid%g(:,ig)
!              END DO
!              DO igauss1 = 1, SIZE(radii)
!                 idim1 = (iparticle1-1)*SIZE(radii)+igauss1
!                 istart_g = 1
!                 IF (iparticle2==iparticle1) istart_g = igauss1
!                 DO igauss2 = istart_g, SIZE(radii)
!                    idim2 = (iparticle2-1)*SIZE(radii)+igauss2
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(1,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,1) = tmp
!                    dAm (idim2,idim1,1) = tmp
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(2,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,2) = tmp
!                    dAm (idim2,idim1,2) = tmp
!                    DO ig = s_dim, igmax
!                       my_Amw(ig) =  my_Am(3,ig)*gfunc(ig,igauss1)*gfunc(ig,igauss2)
!                    END DO
! !NB no loss of accuracy in my test cases
! #ifdef ACCURATE_SUMS
!                    tmp = accurate_sum(my_Amw)
! #else
!                    tmp = SUM(my_Amw)
! #endif
!                    dAm (idim1,idim2,3) = tmp
!                    dAm (idim2,idim1,3) = tmp
!                 END DO
!              END DO
!           END DO
!        END DO
!        DEALLOCATE(my_Amw,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        DEALLOCATE(my_Am,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         !!! DEALLOCATE(arg1_v,stat=stat)
         !!! CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
--- 398,455 ----
            IF (g2 > gcut2) EXIT
            igmax  = ig
         ENDDO
         ALLOCATE(arg1_v_sin(s_dim:igmax),stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  
! ! want dAm(idim1 = (iparticle0-1)*SIZE(radii)+1:(iparticle0-1)*SIZE(radii)+size(radii),1:size(particle_set)*size(radii),1:3)
!        iparticle1 = iparticle0
!        Nr=SIZE(radii)
!        Np=SIZE(particle_set)
!        Ng=igmax-s_dim+1
!        allocate(lhs(Nr,Ng), stat=stat)
!        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        allocate(rhs(Ng,Np*Nr), stat=stat)
!        CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
! 
! 	! fill in RHS
!        do iparticle2=1,Np
! !!	  IF    ((iparticle1 == iparticle0).AND.(iparticle2==iparticle0))  THEN
! !!		factor = 2.0_dp
! !!	  ELSEIF (iparticle1 == iparticle0) THEN
! !!		factor = 1.0_dp
! !!	  ELSEIF (iparticle2 == iparticle0) THEN
! !!		factor = -1.0_dp
! !!	  END IF
! 	  arg1_v_sin(s_dim:igmax) = g_dot_rvec_sin(1:Ng, iparticle2)*g_dot_rvec_cos(1:Ng, iparticle1) - &
! 				    g_dot_rvec_cos(1:Ng, iparticle2)*g_dot_rvec_sin(1:Ng, iparticle1)
! 	  do igauss2=1,Nr
! 	     !! rhs(1:Ng,(iparticle2-1)*Nr+igauss2) = factor*arg1_v_sin(s_dim:igmax)*gfunc(s_dim:igmax,igauss2)
! 	     rhs(1:Ng,(iparticle2-1)*Nr+igauss2) = arg1_v_sin(s_dim:igmax)*gfunc(s_dim:igmax,igauss2)
! 	  end do
!        end do
!        rhs(1:Ng,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr) = 2.0D0*rhs(1:Ng,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr)
! 
!        do icomp=1,3
! 	  ! fill in LHS
! 	  do ig=s_dim,igmax
! 	     lhs(1:Nr,ig-s_dim+1) = w(ig) * rho_tot_g%pw_grid%g(icomp,ig) * gfunc(ig,1:Nr)
! 	  end do
! 	  call DGEMM('N', 'N', Nr, Np*Nr, Ng, 1.0D0, lhs, Nr, rhs, Ng, 0.0D0, dAm((iparticle1-1)*Nr+1,1,icomp), Np*Nr)
!        end do ! icomp
! 
!        if (iparticle0 > 1) then
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,1))
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,2) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,2))
! 	  dAm(1:(iparticle0-1)*Nr+1,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,3) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1:(iparticle0-1)*Nr+1,3))
!        endif
!        if (iparticle0 < Np) then
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,1) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,1))
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,2) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,2))
! 	  dAm(iparticle0*Nr+1:Np*Nr,(iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr,3) = transpose(dAm((iparticle0-1)*Nr+1:(iparticle0-1)*Nr+Nr, iparticle0*Nr+1:Np*Nr,3))
!        endif
!        DEALLOCATE(rhs,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
!        DEALLOCATE(lhs,stat=stat)
         CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
         !!! DEALLOCATE(arg1_v,stat=stat)
         !!! CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
Index: ../src/qmmm_gpw_forces.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/qmmm_gpw_forces.F,v
retrieving revision 1.19
diff -b -c -3 -r1.19 qmmm_gpw_forces.F
*** qmmm_gpw_forces.F	31 Dec 2010 16:04:00 -0000	1.19
--- qmmm_gpw_forces.F	29 Apr 2011 18:39:39 -0000
***************
*** 738,743 ****
--- 738,744 ----
        POINTER                                :: grid, grid2
      TYPE(pw_type), POINTER                   :: pw
      TYPE(qmmm_per_pot_type), POINTER         :: per_pot
+     REAL(KIND=dp) :: abc_X(4,4), abc_X_Y(4)
  
      failure = .FALSE.
      CALL timeset(routineN,handle)
***************
*** 791,885 ****
               my_j = bo(1,2)-gbo(1,2)
               xs2 = REAL(my_j,dp)*dr2c
               rv3 = rt3 - xs3
               DO j =  bo(1,2), bo(2,2)
                  my_i= bo(1,1)-gbo(1,1)
                  xs1 = REAL(my_i,dp)*dr1c
                  rv2 = rt2 - xs2
                  DO i =  bo(1,1), bo(2,1)
                     rv1 = rt1 - xs1
!                    vec = (/rv1,rv2,rv3/)
!                    ivec = FLOOR(vec/pw%pw_grid%dr)
                     xd1  = (vec(1)/dr1)-REAL(ivec(1),kind=dp)
-                    xd2  = (vec(2)/dr2)-REAL(ivec(2),kind=dp)
-                    xd3  = (vec(3)/dr3)-REAL(ivec(3),kind=dp)
-                    ik1 = MODULO(ivec(3)-1,npts(3))+1
-                    ik2 = MODULO(ivec(3)  ,npts(3))+1
-                    ik3 = MODULO(ivec(3)+1,npts(3))+1
-                    ik4 = MODULO(ivec(3)+2,npts(3))+1
-                    ij1 = MODULO(ivec(2)-1,npts(2))+1
-                    ij2 = MODULO(ivec(2)  ,npts(2))+1
-                    ij3 = MODULO(ivec(2)+1,npts(2))+1
-                    ij4 = MODULO(ivec(2)+2,npts(2))+1
-                    ii1 = MODULO(ivec(1)-1,npts(1))+1
-                    ii2 = MODULO(ivec(1)  ,npts(1))+1
-                    ii3 = MODULO(ivec(1)+1,npts(1))+1
-                    ii4 = MODULO(ivec(1)+2,npts(1))+1
- 
-                    aaa   = grid2(ii1,ij1,ik1)
-                    baa   = grid2(ii2,ij1,ik1)
-                    caa   = grid2(ii3,ij1,ik1)
-                    daa   = grid2(ii4,ij1,ik1)
-                    aba   = grid2(ii1,ij2,ik1)
-                    bba   = grid2(ii2,ij2,ik1)
-                    cba   = grid2(ii3,ij2,ik1)
-                    dba   = grid2(ii4,ij2,ik1)
-                    aca   = grid2(ii1,ij3,ik1)
-                    bca   = grid2(ii2,ij3,ik1)
-                    cca   = grid2(ii3,ij3,ik1)
-                    dca   = grid2(ii4,ij3,ik1)
-                    ada   = grid2(ii1,ij4,ik1)
-                    bda   = grid2(ii2,ij4,ik1)
-                    cda   = grid2(ii3,ij4,ik1)
-                    dda   = grid2(ii4,ij4,ik1)
-                    aab   = grid2(ii1,ij1,ik2)
-                    bab   = grid2(ii2,ij1,ik2)
-                    cab   = grid2(ii3,ij1,ik2)
-                    dab   = grid2(ii4,ij1,ik2)
-                    abb   = grid2(ii1,ij2,ik2)
-                    bbb   = grid2(ii2,ij2,ik2)
-                    cbb   = grid2(ii3,ij2,ik2)
-                    dbb   = grid2(ii4,ij2,ik2)
-                    acb   = grid2(ii1,ij3,ik2)
-                    bcb   = grid2(ii2,ij3,ik2)
-                    ccb   = grid2(ii3,ij3,ik2)
-                    dcb   = grid2(ii4,ij3,ik2)
-                    adb   = grid2(ii1,ij4,ik2)
-                    bdb   = grid2(ii2,ij4,ik2)
-                    cdb   = grid2(ii3,ij4,ik2)
-                    ddb   = grid2(ii4,ij4,ik2)
-                    aac   = grid2(ii1,ij1,ik3)
-                    bac   = grid2(ii2,ij1,ik3)
-                    cac   = grid2(ii3,ij1,ik3)
-                    dac   = grid2(ii4,ij1,ik3)
-                    abc   = grid2(ii1,ij2,ik3)
-                    bbc   = grid2(ii2,ij2,ik3)
-                    cbc   = grid2(ii3,ij2,ik3)
-                    dbc   = grid2(ii4,ij2,ik3)
-                    acc   = grid2(ii1,ij3,ik3)
-                    bcc   = grid2(ii2,ij3,ik3)
-                    ccc   = grid2(ii3,ij3,ik3)
-                    dcc   = grid2(ii4,ij3,ik3)
-                    adc   = grid2(ii1,ij4,ik3)
-                    bdc   = grid2(ii2,ij4,ik3)
-                    cdc   = grid2(ii3,ij4,ik3)
-                    ddc   = grid2(ii4,ij4,ik3)
-                    aad   = grid2(ii1,ij1,ik4)
-                    bad   = grid2(ii2,ij1,ik4)
-                    cad   = grid2(ii3,ij1,ik4)
-                    dad   = grid2(ii4,ij1,ik4)
-                    abd   = grid2(ii1,ij2,ik4)
-                    bbd   = grid2(ii2,ij2,ik4)
-                    cbd   = grid2(ii3,ij2,ik4)
-                    dbd   = grid2(ii4,ij2,ik4)
-                    acd   = grid2(ii1,ij3,ik4)
-                    bcd   = grid2(ii2,ij3,ik4)
-                    ccd   = grid2(ii3,ij3,ik4)
-                    dcd   = grid2(ii4,ij3,ik4)
-                    add   = grid2(ii1,ij4,ik4)
-                    bdd   = grid2(ii2,ij4,ik4)
-                    cdd   = grid2(ii3,ij4,ik4)
-                    ddd   = grid2(ii4,ij4,ik4)
- 
                     a1  = 3.0_dp + xd1
                     a2  = a1*a1
                     a3  = a2*a1
--- 792,852 ----
               my_j = bo(1,2)-gbo(1,2)
               xs2 = REAL(my_j,dp)*dr2c
               rv3 = rt3 - xs3
+ 	     vec(3) = rv3
+ 	     ivec(3) = FLOOR(vec(3)/pw%pw_grid%dr(3))
+ 	     xd3  = (vec(3)/dr3)-REAL(ivec(3),kind=dp)
+ 	     p1  = 3.0_dp + xd3
+ 	     p2  = p1*p1
+ 	     p3  = p2*p1
+ 	     q1  = 2.0_dp + xd3
+ 	     q2  = q1*q1
+ 	     q3  = q2*q1
+ 	     r1  = 1.0_dp + xd3
+ 	     r2  = r1*r1
+ 	     r3  = r2*r1
+ 	     u1  = xd3
+ 	     u2  = u1*u1
+ 	     u3  = u2*u1
+ 	     v1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*p1 + 12.0_dp*p2 - p3)
+ 	     v2o = -22.0_dp/3.0_dp + 10.0_dp*q1 - 4.0_dp*q2 + 0.5_dp*q3
+ 	     v3o =   2.0_dp/3.0_dp -  2.0_dp*r1 + 2.0_dp*r2 - 0.5_dp*r3
+ 	     v4o =   1.0_dp/6.0_dp*u3
+ 	     v1d =  -8.0_dp + 4.0_dp*p1 - 0.5_dp*p2
+ 	     v2d =  10.0_dp - 8.0_dp*q1 + 1.5_dp*q2
+ 	     v3d =  -2.0_dp + 4.0_dp*r1 - 1.5_dp*r2
+ 	     v4d =   0.5_dp*u2
               DO j =  bo(1,2), bo(2,2)
                  my_i= bo(1,1)-gbo(1,1)
                  xs1 = REAL(my_i,dp)*dr1c
                  rv2 = rt2 - xs2
+ 	        vec(2) = rv2
+ 	        ivec(2) = FLOOR(vec(2)/pw%pw_grid%dr(2))
+ 		xd2  = (vec(2)/dr2)-REAL(ivec(2),kind=dp)
+ 		e1  = 3.0_dp + xd2
+ 		e2  = e1*e1
+ 		e3  = e2*e1
+ 		f1  = 2.0_dp + xd2
+ 		f2  = f1*f1
+ 		f3  = f2*f1
+ 		g1  = 1.0_dp + xd2
+ 		g2  = g1*g1
+ 		g3  = g2*g1
+ 		h1  = xd2
+ 		h2  = h1*h1
+ 		h3  = h2*h1
+ 		s1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*e1 + 12.0_dp*e2 - e3)
+ 		s2o = -22.0_dp/3.0_dp + 10.0_dp*f1 - 4.0_dp*f2 + 0.5_dp*f3
+ 		s3o =   2.0_dp/3.0_dp -  2.0_dp*g1 + 2.0_dp*g2 - 0.5_dp*g3
+ 		s4o =   1.0_dp/6.0_dp*h3
+ 		s1d =  -8.0_dp + 4.0_dp*e1 - 0.5_dp*e2
+ 		s2d =  10.0_dp - 8.0_dp*f1 + 1.5_dp*f2
+ 		s3d =  -2.0_dp + 4.0_dp*g1 - 1.5_dp*g2
+ 		s4d =   0.5_dp*h2
                  DO i =  bo(1,1), bo(2,1)
                     rv1 = rt1 - xs1
! 		   vec(1) = rv1
! 		   ivec(1) = FLOOR(vec(1)/pw%pw_grid%dr(1))
                     xd1  = (vec(1)/dr1)-REAL(ivec(1),kind=dp)
                     a1  = 3.0_dp + xd1
                     a2  = a1*a1
                     a3  = a2*a1
***************
*** 892,947 ****
                     d1  = xd1
                     d2  = d1*d1
                     d3  = d2*d1
-                    e1  = 3.0_dp + xd2
-                    e2  = e1*e1
-                    e3  = e2*e1
-                    f1  = 2.0_dp + xd2
-                    f2  = f1*f1
-                    f3  = f2*f1
-                    g1  = 1.0_dp + xd2
-                    g2  = g1*g1
-                    g3  = g2*g1
-                    h1  = xd2
-                    h2  = h1*h1
-                    h3  = h2*h1
-                    p1  = 3.0_dp + xd3
-                    p2  = p1*p1
-                    p3  = p2*p1
-                    q1  = 2.0_dp + xd3
-                    q2  = q1*q1
-                    q3  = q2*q1
-                    r1  = 1.0_dp + xd3
-                    r2  = r1*r1
-                    r3  = r2*r1
-                    u1  = xd3
-                    u2  = u1*u1
-                    u3  = u2*u1
- 
                     t1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*a1 + 12.0_dp*a2 - a3)
                     t2o = -22.0_dp/3.0_dp + 10.0_dp*b1 - 4.0_dp*b2 + 0.5_dp*b3
                     t3o =   2.0_dp/3.0_dp -  2.0_dp*c1 + 2.0_dp*c2 - 0.5_dp*c3
                     t4o =   1.0_dp/6.0_dp*d3
-                    s1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*e1 + 12.0_dp*e2 - e3)
-                    s2o = -22.0_dp/3.0_dp + 10.0_dp*f1 - 4.0_dp*f2 + 0.5_dp*f3
-                    s3o =   2.0_dp/3.0_dp -  2.0_dp*g1 + 2.0_dp*g2 - 0.5_dp*g3
-                    s4o =   1.0_dp/6.0_dp*h3
-                    v1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*p1 + 12.0_dp*p2 - p3)
-                    v2o = -22.0_dp/3.0_dp + 10.0_dp*q1 - 4.0_dp*q2 + 0.5_dp*q3
-                    v3o =   2.0_dp/3.0_dp -  2.0_dp*r1 + 2.0_dp*r2 - 0.5_dp*r3
-                    v4o =   1.0_dp/6.0_dp*u3
- 
                     t1d =  -8.0_dp + 4.0_dp*a1 - 0.5_dp*a2
                     t2d =  10.0_dp - 8.0_dp*b1 + 1.5_dp*b2
                     t3d =  -2.0_dp + 4.0_dp*c1 - 1.5_dp*c2
                     t4d =   0.5_dp*d2
!                    s1d =  -8.0_dp + 4.0_dp*e1 - 0.5_dp*e2
!                    s2d =  10.0_dp - 8.0_dp*f1 + 1.5_dp*f2
!                    s3d =  -2.0_dp + 4.0_dp*g1 - 1.5_dp*g2
!                    s4d =   0.5_dp*h2
!                    v1d =  -8.0_dp + 4.0_dp*p1 - 0.5_dp*p2
!                    v2d =  10.0_dp - 8.0_dp*q1 + 1.5_dp*q2
!                    v3d =  -2.0_dp + 4.0_dp*r1 - 1.5_dp*r2
!                    v4d =   0.5_dp*u2
  
                     t1     = t1d*dr1i
                     t2     = t2d*dr1i
--- 859,939 ----
                     d1  = xd1
                     d2  = d1*d1
                     d3  = d2*d1
                     t1o =   1.0_dp/6.0_dp * (64.0_dp - 48.0_dp*a1 + 12.0_dp*a2 - a3)
                     t2o = -22.0_dp/3.0_dp + 10.0_dp*b1 - 4.0_dp*b2 + 0.5_dp*b3
                     t3o =   2.0_dp/3.0_dp -  2.0_dp*c1 + 2.0_dp*c2 - 0.5_dp*c3
                     t4o =   1.0_dp/6.0_dp*d3
                     t1d =  -8.0_dp + 4.0_dp*a1 - 0.5_dp*a2
                     t2d =  10.0_dp - 8.0_dp*b1 + 1.5_dp*b2
                     t3d =  -2.0_dp + 4.0_dp*c1 - 1.5_dp*c2
                     t4d =   0.5_dp*d2
! 
!                    ik1 = MODULO(ivec(3)-1,npts(3))+1
!                    ik2 = MODULO(ivec(3)  ,npts(3))+1
!                    ik3 = MODULO(ivec(3)+1,npts(3))+1
!                    ik4 = MODULO(ivec(3)+2,npts(3))+1
!                    ij1 = MODULO(ivec(2)-1,npts(2))+1
!                    ij2 = MODULO(ivec(2)  ,npts(2))+1
!                    ij3 = MODULO(ivec(2)+1,npts(2))+1
!                    ij4 = MODULO(ivec(2)+2,npts(2))+1
!                    ii1 = MODULO(ivec(1)-1,npts(1))+1
!                    ii2 = MODULO(ivec(1)  ,npts(1))+1
!                    ii3 = MODULO(ivec(1)+1,npts(1))+1
!                    ii4 = MODULO(ivec(1)+2,npts(1))+1
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !
! ! # v then t then s
! !
! ! for ii in 1 2 3; do
! ! if [[ $ii == 1 ]]; then ld=t; fi
! ! if [[ $ii == 2 ]]; then ld=s; fi
! ! if [[ $ii == 3 ]]; then ld=v; fi
! ! #
! ! for l in t s v; do
! ! for i in 1 2 3 4; do
! ! if [[ $ld == $l ]]; then
! !  echo "$l$i = $l${i}d*dr${ii}i"
! ! else
! !  echo "$l$i = $l${i}o"
! ! fi
! ! done
! ! done
! ! #
! ! for i in 1 2 3 4; do
! ! for j in 1 2 3 4; do
! ! echo -n "abc_X($i,$j) = "
! ! for k in 1 2 3 4; do
! ! if [ $k == 4 ]; then
! ! echo "grid2(ii$i,ij$j,ik$k)*v$k"
! ! else
! ! echo -n "grid2(ii$i,ij$j,ik$k)*v$k + "
! ! fi
! ! done
! ! done
! ! done
! ! echo ""
! ! for j in 1 2 3 4; do
! ! echo -n "abc_X_Y($j) = "
! ! for k in 1 2 3 4; do
! ! if [ $k == 4 ]; then
! ! echo "abc_X($k,$j)*t$k"
! ! else
! ! echo -n "abc_X($k,$j)*t$k + "
! ! fi
! ! done
! ! done
! ! echo ""
! ! echo -n "val($ii) = "
! ! for k in 1 2 3 4; do
! ! if [ $k == 4 ]; then
! ! echo "abc_X_Y($k)*s$k"
! ! else
! ! echo -n "abc_X_Y($k)*s$k + "
! ! fi
! ! done
! ! echo ""
! ! done
  
  		   t1 = t1d*dr1i
  		   t2 = t2d*dr1i
***************
*** 955,976 ****
                     v2     = v2o
                     v3     = v3o
                     v4     = v4o
!                    val(1) = (( aaa * t1 + baa * t2 + caa * t3 + daa * t4 ) * s1  +&
!                              ( aba * t1 + bba * t2 + cba * t3 + dba * t4 ) * s2  +&
!                              ( aca * t1 + bca * t2 + cca * t3 + dca * t4 ) * s3  +&
!                              ( ada * t1 + bda * t2 + cda * t3 + dda * t4 ) * s4  ) * v1 +&
!                             (( aab * t1 + bab * t2 + cab * t3 + dab * t4 ) * s1  +&
!                              ( abb * t1 + bbb * t2 + cbb * t3 + dbb * t4 ) * s2  +&
!                              ( acb * t1 + bcb * t2 + ccb * t3 + dcb * t4 ) * s3  +&
!                              ( adb * t1 + bdb * t2 + cdb * t3 + ddb * t4 ) * s4  ) * v2 +&
!                             (( aac * t1 + bac * t2 + cac * t3 + dac * t4 ) * s1  +&
!                              ( abc * t1 + bbc * t2 + cbc * t3 + dbc * t4 ) * s2  +&
!                              ( acc * t1 + bcc * t2 + ccc * t3 + dcc * t4 ) * s3  +&
!                              ( adc * t1 + bdc * t2 + cdc * t3 + ddc * t4 ) * s4  ) * v3 +&
!                             (( aad * t1 + bad * t2 + cad * t3 + dad * t4 ) * s1  +&
!                              ( abd * t1 + bbd * t2 + cbd * t3 + dbd * t4 ) * s2  +&
!                              ( acd * t1 + bcd * t2 + ccd * t3 + dcd * t4 ) * s3  +&
!                              ( add * t1 + bdd * t2 + cdd * t3 + ddd * t4 ) * s4  ) * v4
  
                     t1     = t1o
                     t2     = t2o
--- 947,975 ----
  		   v2 = v2o
  		   v3 = v3o
  		   v4 = v4o
! 		   abc_X(1,1) = grid2(ii1,ij1,ik1)*v1 + grid2(ii1,ij1,ik2)*v2 + grid2(ii1,ij1,ik3)*v3 + grid2(ii1,ij1,ik4)*v4
! 		   abc_X(1,2) = grid2(ii1,ij2,ik1)*v1 + grid2(ii1,ij2,ik2)*v2 + grid2(ii1,ij2,ik3)*v3 + grid2(ii1,ij2,ik4)*v4
! 		   abc_X(1,3) = grid2(ii1,ij3,ik1)*v1 + grid2(ii1,ij3,ik2)*v2 + grid2(ii1,ij3,ik3)*v3 + grid2(ii1,ij3,ik4)*v4
! 		   abc_X(1,4) = grid2(ii1,ij4,ik1)*v1 + grid2(ii1,ij4,ik2)*v2 + grid2(ii1,ij4,ik3)*v3 + grid2(ii1,ij4,ik4)*v4
! 		   abc_X(2,1) = grid2(ii2,ij1,ik1)*v1 + grid2(ii2,ij1,ik2)*v2 + grid2(ii2,ij1,ik3)*v3 + grid2(ii2,ij1,ik4)*v4
! 		   abc_X(2,2) = grid2(ii2,ij2,ik1)*v1 + grid2(ii2,ij2,ik2)*v2 + grid2(ii2,ij2,ik3)*v3 + grid2(ii2,ij2,ik4)*v4
! 		   abc_X(2,3) = grid2(ii2,ij3,ik1)*v1 + grid2(ii2,ij3,ik2)*v2 + grid2(ii2,ij3,ik3)*v3 + grid2(ii2,ij3,ik4)*v4
! 		   abc_X(2,4) = grid2(ii2,ij4,ik1)*v1 + grid2(ii2,ij4,ik2)*v2 + grid2(ii2,ij4,ik3)*v3 + grid2(ii2,ij4,ik4)*v4
! 		   abc_X(3,1) = grid2(ii3,ij1,ik1)*v1 + grid2(ii3,ij1,ik2)*v2 + grid2(ii3,ij1,ik3)*v3 + grid2(ii3,ij1,ik4)*v4
! 		   abc_X(3,2) = grid2(ii3,ij2,ik1)*v1 + grid2(ii3,ij2,ik2)*v2 + grid2(ii3,ij2,ik3)*v3 + grid2(ii3,ij2,ik4)*v4
! 		   abc_X(3,3) = grid2(ii3,ij3,ik1)*v1 + grid2(ii3,ij3,ik2)*v2 + grid2(ii3,ij3,ik3)*v3 + grid2(ii3,ij3,ik4)*v4
! 		   abc_X(3,4) = grid2(ii3,ij4,ik1)*v1 + grid2(ii3,ij4,ik2)*v2 + grid2(ii3,ij4,ik3)*v3 + grid2(ii3,ij4,ik4)*v4
! 		   abc_X(4,1) = grid2(ii4,ij1,ik1)*v1 + grid2(ii4,ij1,ik2)*v2 + grid2(ii4,ij1,ik3)*v3 + grid2(ii4,ij1,ik4)*v4
! 		   abc_X(4,2) = grid2(ii4,ij2,ik1)*v1 + grid2(ii4,ij2,ik2)*v2 + grid2(ii4,ij2,ik3)*v3 + grid2(ii4,ij2,ik4)*v4
! 		   abc_X(4,3) = grid2(ii4,ij3,ik1)*v1 + grid2(ii4,ij3,ik2)*v2 + grid2(ii4,ij3,ik3)*v3 + grid2(ii4,ij3,ik4)*v4
! 		   abc_X(4,4) = grid2(ii4,ij4,ik1)*v1 + grid2(ii4,ij4,ik2)*v2 + grid2(ii4,ij4,ik3)*v3 + grid2(ii4,ij4,ik4)*v4
! 
! 		   abc_X_Y(1) = abc_X(1,1)*t1 + abc_X(2,1)*t2 + abc_X(3,1)*t3 + abc_X(4,1)*t4
! 		   abc_X_Y(2) = abc_X(1,2)*t1 + abc_X(2,2)*t2 + abc_X(3,2)*t3 + abc_X(4,2)*t4
! 		   abc_X_Y(3) = abc_X(1,3)*t1 + abc_X(2,3)*t2 + abc_X(3,3)*t3 + abc_X(4,3)*t4
! 		   abc_X_Y(4) = abc_X(1,4)*t1 + abc_X(2,4)*t2 + abc_X(3,4)*t3 + abc_X(4,4)*t4
! 
! 		   val(1) = abc_X_Y(1)*s1 + abc_X_Y(2)*s2 + abc_X_Y(3)*s3 + abc_X_Y(4)*s4
  
  		   t1 = t1o
  		   t2 = t2o
***************
*** 980,1005 ****
                     s2     = s2d*dr2i
                     s3     = s3d*dr2i
                     s4     = s4d*dr2i
!                    v1     = v1o
!                    v2     = v2o
!                    v3     = v3o
!                    v4     = v4o
!                    val(2) = (( aaa * t1 + baa * t2 + caa * t3 + daa * t4 ) * s1  +&
!                              ( aba * t1 + bba * t2 + cba * t3 + dba * t4 ) * s2  +&
!                              ( aca * t1 + bca * t2 + cca * t3 + dca * t4 ) * s3  +&
!                              ( ada * t1 + bda * t2 + cda * t3 + dda * t4 ) * s4  ) * v1 +&
!                             (( aab * t1 + bab * t2 + cab * t3 + dab * t4 ) * s1  +&
!                              ( abb * t1 + bbb * t2 + cbb * t3 + dbb * t4 ) * s2  +&
!                              ( acb * t1 + bcb * t2 + ccb * t3 + dcb * t4 ) * s3  +&
!                              ( adb * t1 + bdb * t2 + cdb * t3 + ddb * t4 ) * s4  ) * v2 +&
!                             (( aac * t1 + bac * t2 + cac * t3 + dac * t4 ) * s1  +&
!                              ( abc * t1 + bbc * t2 + cbc * t3 + dbc * t4 ) * s2  +&
!                              ( acc * t1 + bcc * t2 + ccc * t3 + dcc * t4 ) * s3  +&
!                              ( adc * t1 + bdc * t2 + cdc * t3 + ddc * t4 ) * s4  ) * v3 +&
!                             (( aad * t1 + bad * t2 + cad * t3 + dad * t4 ) * s1  +&
!                              ( abd * t1 + bbd * t2 + cbd * t3 + dbd * t4 ) * s2  +&
!                              ( acd * t1 + bcd * t2 + ccd * t3 + dcd * t4 ) * s3  +&
!                              ( add * t1 + bdd * t2 + cdd * t3 + ddd * t4 ) * s4  ) * v4
  
                     t1     = t1o
                     t2     = t2o
--- 979,1011 ----
  		   s2 = s2d*dr2i
  		   s3 = s3d*dr2i
  		   s4 = s4d*dr2i
! 		   !! v1 = v1o
! 		   !! v2 = v2o
! 		   !! v3 = v3o
! 		   !! v4 = v4o
! 		   !! abc_X(1,1) = grid2(ii1,ij1,ik1)*v1 + grid2(ii1,ij1,ik2)*v2 + grid2(ii1,ij1,ik3)*v3 + grid2(ii1,ij1,ik4)*v4
! 		   !! abc_X(1,2) = grid2(ii1,ij2,ik1)*v1 + grid2(ii1,ij2,ik2)*v2 + grid2(ii1,ij2,ik3)*v3 + grid2(ii1,ij2,ik4)*v4
! 		   !! abc_X(1,3) = grid2(ii1,ij3,ik1)*v1 + grid2(ii1,ij3,ik2)*v2 + grid2(ii1,ij3,ik3)*v3 + grid2(ii1,ij3,ik4)*v4
! 		   !! abc_X(1,4) = grid2(ii1,ij4,ik1)*v1 + grid2(ii1,ij4,ik2)*v2 + grid2(ii1,ij4,ik3)*v3 + grid2(ii1,ij4,ik4)*v4
! 		   !! abc_X(2,1) = grid2(ii2,ij1,ik1)*v1 + grid2(ii2,ij1,ik2)*v2 + grid2(ii2,ij1,ik3)*v3 + grid2(ii2,ij1,ik4)*v4
! 		   !! abc_X(2,2) = grid2(ii2,ij2,ik1)*v1 + grid2(ii2,ij2,ik2)*v2 + grid2(ii2,ij2,ik3)*v3 + grid2(ii2,ij2,ik4)*v4
! 		   !! abc_X(2,3) = grid2(ii2,ij3,ik1)*v1 + grid2(ii2,ij3,ik2)*v2 + grid2(ii2,ij3,ik3)*v3 + grid2(ii2,ij3,ik4)*v4
! 		   !! abc_X(2,4) = grid2(ii2,ij4,ik1)*v1 + grid2(ii2,ij4,ik2)*v2 + grid2(ii2,ij4,ik3)*v3 + grid2(ii2,ij4,ik4)*v4
! 		   !! abc_X(3,1) = grid2(ii3,ij1,ik1)*v1 + grid2(ii3,ij1,ik2)*v2 + grid2(ii3,ij1,ik3)*v3 + grid2(ii3,ij1,ik4)*v4
! 		   !! abc_X(3,2) = grid2(ii3,ij2,ik1)*v1 + grid2(ii3,ij2,ik2)*v2 + grid2(ii3,ij2,ik3)*v3 + grid2(ii3,ij2,ik4)*v4
! 		   !! abc_X(3,3) = grid2(ii3,ij3,ik1)*v1 + grid2(ii3,ij3,ik2)*v2 + grid2(ii3,ij3,ik3)*v3 + grid2(ii3,ij3,ik4)*v4
! 		   !! abc_X(3,4) = grid2(ii3,ij4,ik1)*v1 + grid2(ii3,ij4,ik2)*v2 + grid2(ii3,ij4,ik3)*v3 + grid2(ii3,ij4,ik4)*v4
! 		   !! abc_X(4,1) = grid2(ii4,ij1,ik1)*v1 + grid2(ii4,ij1,ik2)*v2 + grid2(ii4,ij1,ik3)*v3 + grid2(ii4,ij1,ik4)*v4
! 		   !! abc_X(4,2) = grid2(ii4,ij2,ik1)*v1 + grid2(ii4,ij2,ik2)*v2 + grid2(ii4,ij2,ik3)*v3 + grid2(ii4,ij2,ik4)*v4
! 		   !! abc_X(4,3) = grid2(ii4,ij3,ik1)*v1 + grid2(ii4,ij3,ik2)*v2 + grid2(ii4,ij3,ik3)*v3 + grid2(ii4,ij3,ik4)*v4
! 		   !! abc_X(4,4) = grid2(ii4,ij4,ik1)*v1 + grid2(ii4,ij4,ik2)*v2 + grid2(ii4,ij4,ik3)*v3 + grid2(ii4,ij4,ik4)*v4
! 
! 		   abc_X_Y(1) = abc_X(1,1)*t1 + abc_X(2,1)*t2 + abc_X(3,1)*t3 + abc_X(4,1)*t4
! 		   abc_X_Y(2) = abc_X(1,2)*t1 + abc_X(2,2)*t2 + abc_X(3,2)*t3 + abc_X(4,2)*t4
! 		   abc_X_Y(3) = abc_X(1,3)*t1 + abc_X(2,3)*t2 + abc_X(3,3)*t3 + abc_X(4,3)*t4
! 		   abc_X_Y(4) = abc_X(1,4)*t1 + abc_X(2,4)*t2 + abc_X(3,4)*t3 + abc_X(4,4)*t4
! 
! 		   val(2) = abc_X_Y(1)*s1 + abc_X_Y(2)*s2 + abc_X_Y(3)*s3 + abc_X_Y(4)*s4
  
  		   t1 = t1o
  		   t2 = t2o
***************
*** 1013,1034 ****
                     v2     = v2d*dr3i
                     v3     = v3d*dr3i
                     v4     = v4d*dr3i
!                    val(3) = (( aaa * t1 + baa * t2 + caa * t3 + daa * t4 ) * s1  +&
!                              ( aba * t1 + bba * t2 + cba * t3 + dba * t4 ) * s2  +&
!                              ( aca * t1 + bca * t2 + cca * t3 + dca * t4 ) * s3  +&
!                              ( ada * t1 + bda * t2 + cda * t3 + dda * t4 ) * s4  ) * v1 +&
!                             (( aab * t1 + bab * t2 + cab * t3 + dab * t4 ) * s1  +&
!                              ( abb * t1 + bbb * t2 + cbb * t3 + dbb * t4 ) * s2  +&
!                              ( acb * t1 + bcb * t2 + ccb * t3 + dcb * t4 ) * s3  +&
!                              ( adb * t1 + bdb * t2 + cdb * t3 + ddb * t4 ) * s4  ) * v2 +&
!                             (( aac * t1 + bac * t2 + cac * t3 + dac * t4 ) * s1  +&
!                              ( abc * t1 + bbc * t2 + cbc * t3 + dbc * t4 ) * s2  +&
!                              ( acc * t1 + bcc * t2 + ccc * t3 + dcc * t4 ) * s3  +&
!                              ( adc * t1 + bdc * t2 + cdc * t3 + ddc * t4 ) * s4  ) * v3 +&
!                             (( aad * t1 + bad * t2 + cad * t3 + dad * t4 ) * s1  +&
!                              ( abd * t1 + bbd * t2 + cbd * t3 + dbd * t4 ) * s2  +&
!                              ( acd * t1 + bcd * t2 + ccd * t3 + dcd * t4 ) * s3  +&
!                              ( add * t1 + bdd * t2 + cdd * t3 + ddd * t4 ) * s4  ) * v4
  
                     fac = grid(i,j,k)
                     ft1 = ft1 + val(1) * fac
--- 1019,1048 ----
  		   v2 = v2d*dr3i
  		   v3 = v3d*dr3i
  		   v4 = v4d*dr3i
! 		   abc_X(1,1) = grid2(ii1,ij1,ik1)*v1 + grid2(ii1,ij1,ik2)*v2 + grid2(ii1,ij1,ik3)*v3 + grid2(ii1,ij1,ik4)*v4
! 		   abc_X(1,2) = grid2(ii1,ij2,ik1)*v1 + grid2(ii1,ij2,ik2)*v2 + grid2(ii1,ij2,ik3)*v3 + grid2(ii1,ij2,ik4)*v4
! 		   abc_X(1,3) = grid2(ii1,ij3,ik1)*v1 + grid2(ii1,ij3,ik2)*v2 + grid2(ii1,ij3,ik3)*v3 + grid2(ii1,ij3,ik4)*v4
! 		   abc_X(1,4) = grid2(ii1,ij4,ik1)*v1 + grid2(ii1,ij4,ik2)*v2 + grid2(ii1,ij4,ik3)*v3 + grid2(ii1,ij4,ik4)*v4
! 		   abc_X(2,1) = grid2(ii2,ij1,ik1)*v1 + grid2(ii2,ij1,ik2)*v2 + grid2(ii2,ij1,ik3)*v3 + grid2(ii2,ij1,ik4)*v4
! 		   abc_X(2,2) = grid2(ii2,ij2,ik1)*v1 + grid2(ii2,ij2,ik2)*v2 + grid2(ii2,ij2,ik3)*v3 + grid2(ii2,ij2,ik4)*v4
! 		   abc_X(2,3) = grid2(ii2,ij3,ik1)*v1 + grid2(ii2,ij3,ik2)*v2 + grid2(ii2,ij3,ik3)*v3 + grid2(ii2,ij3,ik4)*v4
! 		   abc_X(2,4) = grid2(ii2,ij4,ik1)*v1 + grid2(ii2,ij4,ik2)*v2 + grid2(ii2,ij4,ik3)*v3 + grid2(ii2,ij4,ik4)*v4
! 		   abc_X(3,1) = grid2(ii3,ij1,ik1)*v1 + grid2(ii3,ij1,ik2)*v2 + grid2(ii3,ij1,ik3)*v3 + grid2(ii3,ij1,ik4)*v4
! 		   abc_X(3,2) = grid2(ii3,ij2,ik1)*v1 + grid2(ii3,ij2,ik2)*v2 + grid2(ii3,ij2,ik3)*v3 + grid2(ii3,ij2,ik4)*v4
! 		   abc_X(3,3) = grid2(ii3,ij3,ik1)*v1 + grid2(ii3,ij3,ik2)*v2 + grid2(ii3,ij3,ik3)*v3 + grid2(ii3,ij3,ik4)*v4
! 		   abc_X(3,4) = grid2(ii3,ij4,ik1)*v1 + grid2(ii3,ij4,ik2)*v2 + grid2(ii3,ij4,ik3)*v3 + grid2(ii3,ij4,ik4)*v4
! 		   abc_X(4,1) = grid2(ii4,ij1,ik1)*v1 + grid2(ii4,ij1,ik2)*v2 + grid2(ii4,ij1,ik3)*v3 + grid2(ii4,ij1,ik4)*v4
! 		   abc_X(4,2) = grid2(ii4,ij2,ik1)*v1 + grid2(ii4,ij2,ik2)*v2 + grid2(ii4,ij2,ik3)*v3 + grid2(ii4,ij2,ik4)*v4
! 		   abc_X(4,3) = grid2(ii4,ij3,ik1)*v1 + grid2(ii4,ij3,ik2)*v2 + grid2(ii4,ij3,ik3)*v3 + grid2(ii4,ij3,ik4)*v4
! 		   abc_X(4,4) = grid2(ii4,ij4,ik1)*v1 + grid2(ii4,ij4,ik2)*v2 + grid2(ii4,ij4,ik3)*v3 + grid2(ii4,ij4,ik4)*v4
! 
! 		   abc_X_Y(1) = abc_X(1,1)*t1 + abc_X(2,1)*t2 + abc_X(3,1)*t3 + abc_X(4,1)*t4
! 		   abc_X_Y(2) = abc_X(1,2)*t1 + abc_X(2,2)*t2 + abc_X(3,2)*t3 + abc_X(4,2)*t4
! 		   abc_X_Y(3) = abc_X(1,3)*t1 + abc_X(2,3)*t2 + abc_X(3,3)*t3 + abc_X(4,3)*t4
! 		   abc_X_Y(4) = abc_X(1,4)*t1 + abc_X(2,4)*t2 + abc_X(3,4)*t3 + abc_X(4,4)*t4
! 
! 		   val(3) = abc_X_Y(1)*s1 + abc_X_Y(2)*s2 + abc_X_Y(3)*s3 + abc_X_Y(4)*s4
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  
                     fac = grid(i,j,k)
                     ft1 = ft1 + val(1) * fac
