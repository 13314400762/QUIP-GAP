Index: cp_ddapc_methods.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_methods.F,v
retrieving revision 1.41
diff -u -r1.41 cp_ddapc_methods.F
--- cp_ddapc_methods.F	8 Apr 2010 19:18:04 -0000	1.41
+++ cp_ddapc_methods.F	13 Aug 2010 16:15:21 -0000
@@ -506,7 +506,8 @@
           DEALLOCATE(AmE, stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
        END IF
-       CALL invert_matrix(Am, AmI, inv_error, "N",error=error)
+       !!NB speedup
+       CALL invert_matrix(Am, AmI, inv_error, "N",error=error, improve=.false.)
        IF (iw>0) THEN
           WRITE(iw,'(T3,A,F15.9)')" Error inverting the A matrix: ", inv_error
        END IF
Index: cp_ddapc_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/cp_ddapc_util.F,v
retrieving revision 1.23
diff -u -r1.23 cp_ddapc_util.F
--- cp_ddapc_util.F	3 Jan 2010 23:41:26 -0000	1.23
+++ cp_ddapc_util.F	13 Aug 2010 16:15:21 -0000
@@ -238,6 +238,10 @@
     TYPE(pw_type), POINTER                   :: rho_tot_g
     TYPE(qs_charges_type), POINTER           :: qs_charges
     TYPE(qs_rho_type), POINTER               :: rho
+    !!NB speed
+    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: cvT_AmI, AmI_cv, cvT_AmI_dAmj, dAm_qv, AmI_bv, AmI_dbvj
+    external dgemv
+    !!
 
     CALL timeset(routineN,handle)
     failure         = .FALSE.
@@ -388,6 +392,7 @@
        !
        IF (need_f) THEN 
           CALL timeset(routineN//"-forces",handle3)
+!CALL timeset(routineN//"-for-1",handlet)
           IF (iw>0) THEN
              WRITE(iw,'(T3,A)')" Evaluating DDAPC atomic derivatives .."
           END IF
@@ -399,13 +404,31 @@
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           ALLOCATE(dqv(ndim,SIZE(particle_set),3), stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)     
+	  !!NB speed
+	  ALLOCATE(cvT_AmI(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(cvT_AmI_dAmj(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(AmI_cv(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  cvT_AmI = MATMUL(cv, cp_ddapc_env%AmI)
+	  AmI_cv = MATMUL(cp_ddapc_env%AmI,cv)
+	  ALLOCATE(dAm_qv(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(AmI_bv(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  ALLOCATE(AmI_dbvj(ndim), stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+!CALL timestop(handlet)
+	  !!
           !
           DO iparticle = 1, SIZE(particle_set)
+!CALL timeset(routineN//"-for-2",handlet)
              dAm = 0.0_dp
              dbv = 0.0_dp
              CALL build_der_b_vector(dbv, cp_ddapc_env%gfunc, cp_ddapc_env%w,&
                   particle_set, radii, rho_tot_g, gcut, iparticle, error);  dbv = dbv / Vol
-             CALL mp_sum(dbv,rho_tot_g%pw_grid%para%group)
+!! NB parallelization            CALL mp_sum(dbv,rho_tot_g%pw_grid%para%group)
              IF (debug_this_module) THEN
                 CALL debug_der_b_vector(dbv, particle_set, radii, rho_tot_g,&
                      gcut, iparticle, Vol, qs_env, error)
@@ -413,23 +436,50 @@
              END IF
              CALL build_der_A_matrix(dAm, cp_ddapc_env%gfunc, cp_ddapc_env%w,&
                   particle_set, radii, rho_tot_g, gcut, iparticle, error);  dAm = dAm /(Vol*Vol)
-             CALL mp_sum(dAm,rho_tot_g%pw_grid%para%group)             
+!! NB parallelization            CALL mp_sum(dAm,rho_tot_g%pw_grid%para%group)             
              IF (debug_this_module) THEN
                 CALL debug_der_A_matrix(dAm, particle_set, radii, rho_tot_g,&
                      gcut, iparticle, Vol, qs_env, error)
                 cp_ddapc_env => qs_env%cp_ddapc_env 
              END IF
+!CALL timestop(handlet)
              DO j = 1, 3
-                dqv0 = - MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),-qv))
-                c3 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,bv)))) + &
-                       DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,dbv(:,j))) 
+!CALL timeset(routineN//"-for-3-1",handlet)
+		!!NB speed
+		!! cvT_AmI_dAmj = MATMUL(cvT_AmI, dAm(:,:,j))
+		call dgemv('T', size(dAm,1), size(dAm,2), 1.0_dp, dAm(:,:,j), size(dAm,1), cvT_AmI, 1, 0.0_dp, cvT_AmI_dAmj, 1)
+!CALL timestop(handlet)
+!CALL timeset(routineN//"-for-3-2",handlet)
+		!! dAm_qv = MATMUL(dAm(:,:,j), qv)
+		call dgemv('N', size(dAm,1), size(dAm,2), 1.0_dp, dAm(:,:,j), size(dAm,1), qv, 1, 0.0_dp, dAm_qv, 1)
+                !! dqv0 = MATMUL(cp_ddapc_env%AmI,dAm_qv)
+		call dgemv('N', size(cp_ddapc_env%AmI,1), size(cp_ddapc_env%AmI,2), 1.0_dp, cp_ddapc_env%AmI, size(cp_ddapc_env%AmI,1), dAm_qv, 1, 0.0_dp, dqv0, 1)
+		!! c3 = - DOT_PRODUCT(cvT_AmI_dAmj,MATMUL(cp_ddapc_env%AmI,bv)) + DOT_PRODUCT(cvT_AmI, dbv(:,j))
+		call dgemv('N', size(cp_ddapc_env%AmI,1), size(cp_ddapc_env%AmI,2), 1.0_dp, cp_ddapc_env%AmI, size(cp_ddapc_env%AmI,1), bv, 1, 0.0_dp, AmI_bv, 1)
+!CALL timestop(handlet)
+!CALL timeset(routineN//"-for-3-3",handlet)
+		c3 = - DOT_PRODUCT(cvT_AmI_dAmj,AmI_bv) + DOT_PRODUCT(cvT_AmI, dbv(:,j))
                 c3   = c3 / cp_ddapc_env%c0
-                c4 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,cv)))) / &
-                     cp_ddapc_env%c0
-                dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - &
-                     c3 * MATMUL(cp_ddapc_env%AmI,cv) + c4 * c1 * MATMUL(cp_ddapc_env%AmI,cv))
+		c4 = - DOT_PRODUCT(cvT_AmI_dAmj,AmI_cv) / cp_ddapc_env%c0
+		!! dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - (c3 - c4*c1) * AmI_cv)
+		call dgemv('N', size(cp_ddapc_env%AmI,1), size(cp_ddapc_env%AmI,2), 1.0_dp, cp_ddapc_env%AmI, size(cp_ddapc_env%AmI,1), dbv(:,j), 1, 0.0_dp, AmI_dbvj, 1)
+		dqv(:,iparticle,j) = - ( dqv0 + AmI_dbvj - (c3 - c4*c1) * AmI_cv)
+                ! dqv0 = - MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),-qv))
+                ! c3 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,bv)))) + &
+                       ! DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,dbv(:,j))) 
+                ! c3   = c3 / cp_ddapc_env%c0
+                ! c4 = - DOT_PRODUCT(cv,MATMUL(cp_ddapc_env%AmI,MATMUL(dAm(:,:,j),MATMUL(cp_ddapc_env%AmI,cv)))) / &
+                     ! cp_ddapc_env%c0
+                ! dqv(:,iparticle,j) = - ( dqv0 + MATMUL(cp_ddapc_env%AmI,dbv(:,j)) - &
+                     ! c3 * MATMUL(cp_ddapc_env%AmI,cv) + c4 * c1 * MATMUL(cp_ddapc_env%AmI,cv))
+!CALL timestop(handlet)
              END DO
           END DO
+!CALL timeset(routineN//"-for-4",handlet)
+	  !! NB parallelization
+          CALL mp_sum(dqv,rho_tot_g%pw_grid%para%group)             
+	  !!
+!CALL timestop(handlet)
           CPPostcondition(PRESENT(dq_out),cp_failure_level,routineP,error,failure)
           IF (.NOT.ASSOCIATED(dq_out)) THEN
              ALLOCATE(dq_out(SIZE(dqv,1),SIZE(dqv,2),SIZE(dqv,3)), stat=stat)
@@ -453,6 +503,18 @@
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           DEALLOCATE(dbv, stat=stat)
           CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(cvT_AmI, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(cvT_AmI_dAmj, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+          DEALLOCATE(AmI_cv, stat=stat)
+          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  DEALLOCATE(dAm_qv, stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  DEALLOCATE(AmI_bv, stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
+	  DEALLOCATE(AmI_dbvj, stat=stat)
+	  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
           CALL timestop(handle3)
        END IF
        !
Index: ewald_spline_util.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/ewald_spline_util.F,v
retrieving revision 1.26
diff -u -r1.26 ewald_spline_util.F
--- ewald_spline_util.F	3 Jan 2010 23:41:27 -0000	1.26
+++ ewald_spline_util.F	13 Aug 2010 16:15:21 -0000
@@ -41,6 +41,9 @@
                                              pw_type
   USE timings,                         ONLY: timeset,&
                                              timestop
+  !! NB parallelization
+  USE message_passing,                 ONLY: mp_sum
+  !!
 #include "cp_common_uses.h"
 
   IMPLICIT NONE
@@ -150,6 +153,9 @@
                                                 Term, xs1, xs2, xs3
     TYPE(pw_spline_precond_type), POINTER    :: precond
     TYPE(section_vals_type), POINTER         :: interp_section
+    !! NB parallelization
+    integer :: iii
+    !!
 
     CALL timeset(routineN,handle)
     n1  = grid%pw_grid%npts(1)
@@ -171,6 +177,9 @@
     CALL pw_zero(grid, error=error)
 
     ! Used the full symmetry to reduce the evaluation to 1/64th
+    !! NB parallelization
+    iii = 0
+    !!
     LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
        my_k  = k-gbo(1,3)
        xs3   = REAL(my_k,dp)*dr3
@@ -181,17 +190,25 @@
           xs1   = 0.0_dp
           DO i  =  gbo(1,1), gbo(2,1)
              IF (i > nxlim ) CYCLE
-             Term  = 0.0_dp
-             ! Sum over k vectors
-             DO kg = 1, SIZE(Lg)
-                Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
-             END DO
-             grid%cr3d(i,j,k) = Term
+	     !! NB parallelization
+	     iii = iii + 1
+	     IF (mod(iii,grid%pw_grid%para%group_size) == grid%pw_grid%para%my_pos) THEN
+	       Term  = 0.0_dp
+	       ! Sum over k vectors
+	       DO kg = 1, SIZE(Lg)
+		  Term = Term + lg(kg)*COS(gx(kg)*xs1+gy(kg)*xs2+gz(kg)*xs3)
+	       END DO
+	       grid%cr3d(i,j,k) = Term
+	     ENDIF
+	     !!
              xs1 = xs1 + dr1
           END DO
           xs2 = xs2 + dr2
        END DO
     END DO LoopOnGrid
+    !! NB parallelization
+    call mp_sum(grid%cr3d(gbo(1,1):nxlim,gbo(1,2):nylim,gbo(1,3):nzlim), grid%pw_grid%para%group)
+    !!
 
     Fake_LoopOnGrid: DO k = gbo(1,3), gbo(2,3)
        my_k = k
Index: mathlib.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/mathlib.F,v
retrieving revision 1.45
diff -u -r1.45 mathlib.F
--- mathlib.F	3 Jan 2010 23:41:36 -0000	1.45
+++ mathlib.F	13 Aug 2010 16:15:21 -0000
@@ -466,7 +466,7 @@
 !>       -            "T" => invert transpose(a)
 !> \version 1.0
 ! *****************************************************************************
-  SUBROUTINE invert_matrix_d(a,a_inverse,eval_error,option,error)
+  SUBROUTINE invert_matrix_d(a,a_inverse,eval_error,option,error,improve)
     REAL(KIND=dp), DIMENSION(:, :), &
       INTENT(IN)                             :: a
     REAL(KIND=dp), DIMENSION(:, :), &
@@ -474,6 +474,7 @@
     REAL(KIND=dp), INTENT(OUT)               :: eval_error
     CHARACTER(LEN=1), INTENT(IN), OPTIONAL   :: option
     TYPE(cp_error_type), INTENT(inout)       :: error
+    LOGICAL, INTENT(IN), OPTIONAL            :: improve
 
     CHARACTER(LEN=*), PARAMETER :: routineN = 'invert_matrix_d', &
       routineP = moduleN//':'//routineN
@@ -488,6 +489,7 @@
     REAL(KIND=dp), ALLOCATABLE, &
       DIMENSION(:, :)                        :: a_lu, b
     REAL(KIND=dp), EXTERNAL                  :: dlange
+    LOGICAL                                  :: do_improve
 
     EXTERNAL dgecon,dgerfs,dgetrf,dgetrs
 
@@ -500,6 +502,12 @@
       trans = "N"
     END IF
 
+    IF (PRESENT(improve)) THEN
+      do_improve = improve
+    ELSE
+      do_improve = .true.
+    ENDIF
+
     ! Get the dimension of matrix a
     n = SIZE(a,1)
 
@@ -596,22 +604,24 @@
 
     eval_error = 0.0_dp
 
-    DO iter=1,10
+    IF (do_improve) THEN
+      DO iter=1,10
 
-      CALL dgerfs(trans,n,n,a,n,a_lu,n,ipiv,b,n,a_inverse,n,ferr,berr,&
-                  work,iwork,info)
+	CALL dgerfs(trans,n,n,a,n,a_lu,n,ipiv,b,n,a_inverse,n,ferr,berr,&
+		    work,iwork,info)
 
-      IF (info /= 0) THEN
-        CALL stop_program(moduleN,routineN,__LINE__,&
-                          "Improving the computed solution in dgerfs failed")
-      END IF
+	IF (info /= 0) THEN
+	  CALL stop_program(moduleN,routineN,__LINE__,&
+			    "Improving the computed solution in dgerfs failed")
+	END IF
 
-      old_eval_error = eval_error
-      eval_error = MAXVAL(ferr)
+	old_eval_error = eval_error
+	eval_error = MAXVAL(ferr)
 
-      IF (ABS(eval_error - old_eval_error) <= EPSILON(1.0_dp)) EXIT
+	IF (ABS(eval_error - old_eval_error) <= EPSILON(1.0_dp)) EXIT
 
-    END DO
+      END DO
+    ENDIF
 
     ! Release work storage
     DEALLOCATE (work,STAT=stat)
Index: pw_grids.F
===================================================================
RCS file: /cvsroot/cp2k/cp2k/src/pw_grids.F,v
retrieving revision 1.111
diff -u -r1.111 pw_grids.F
--- pw_grids.F	3 Jan 2010 23:41:36 -0000	1.111
+++ pw_grids.F	13 Aug 2010 16:15:22 -0000
@@ -806,7 +806,7 @@
        CASE DEFAULT
           CPPrecondition(.FALSE.,cp_failure_level,routineP,error,failure)
        END SELECT
-       
+
        !..create group for real space distribution
        CALL mp_cart_create ( pw_grid % para % group, 2, &
             pw_grid % para % rs_dims, &
@@ -876,7 +876,7 @@
           i2 = SIZE ( yz_mask, 2 )
           ALLOCATE ( yz_index(2,i1*i2), STAT = ierr )
           CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
-          CALL order_mask ( yz_mask, yz_index, error )
+          CALL order_mask ( yz_mask, yz_index, error , pw_grid%para%my_pos)
           DO i = 1, i1*i2
              lo(1) = yz_index(1,i)
              lo(2) = yz_index(2,i)
@@ -1097,11 +1097,12 @@
   !------------------------------------------------------------------------------
 
 ! *****************************************************************************
-  SUBROUTINE order_mask ( yz_mask, yz_index, error )
+  SUBROUTINE order_mask ( yz_mask, yz_index, error , my_pos)
 
     INTEGER, DIMENSION(:, :), INTENT(IN)     :: yz_mask
     INTEGER, DIMENSION(:, :), INTENT(OUT)    :: yz_index
     TYPE(cp_error_type), INTENT(inout)       :: error
+integer, intent(in) :: my_pos
 
     CHARACTER(len=*), PARAMETER :: routineN = 'order_mask', &
       routineP = moduleN//':'//routineN
@@ -1110,9 +1111,13 @@
                                                 j1, j2
     INTEGER, ALLOCATABLE, DIMENSION(:)       :: cindex, icol, irow, rindex
     LOGICAL                                  :: failure
+!NB load balance
+integer :: im, ic, jc, ii, jj, iit, jjt, ii_lb, ii_ub, jj_lb, jj_ub
 
 !------------------------------------------------------------------------------
 
+
+#ifdef ORIGINAL_RAY_DISTRIBUTION
     failure = .FALSE.
 
     i1 = SIZE ( yz_mask, 1 )
@@ -1153,6 +1158,164 @@
     DEALLOCATE ( irow, rindex, icol, cindex, STAT = ierr )
     CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
 
+#else
+
+#ifdef RAY_SPIRAL_DISTRIBUTION_SLOW
+
+   icount = 1
+   ic=i1/2
+   jc=i2/2
+   ii=1
+   jj=1
+   if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+      if (yz_mask(ii,jj) /= 0) then
+	 yz_index(1,icount) = ii
+	 yz_index(2,icount) = jj
+	 icount = icount + 1
+      endif
+   endif
+   do im=1, max(ic,jc)
+
+      if (mod(i1,2) == 0) then
+	 ii_lb = max(1-im,1-ic+1)
+      else
+	 ii_lb = max(1-im,1-ic)
+      endif
+      ii_ub = min(1+im,1+ic)
+
+      if (mod(i2,2) == 0) then
+	 jj_lb = max(1-im,1-jc+1)
+      else
+	 jj_lb = max(1-im,1-jc)
+      endif
+      jj_ub = min(1+im,1+jc)
+
+      if (im < ic .or. (im == ic .and. mod(i1,2) /= 0)) then
+	 ii = 1-im+i1
+	 do jj=jj_lb, jj_ub
+	    jjt = jj
+	    if (jjt <= 0) jjt = jjt + i2
+	    if (ii > 0 .and. ii <= i1 .and. jjt > 0 .and. jjt <= i2) then
+	       if (yz_mask(ii,jjt) /= 0) then
+		  yz_index(1,icount) = ii
+		  yz_index(2,icount) = jjt
+		  icount = icount + 1
+	       endif
+	    endif
+	 end do
+      endif
+
+      if (im <= ic) then
+	 ii = 1+im
+	 do jj=jj_lb, jj_ub
+	    jjt = jj
+	    if (jjt <= 0) jjt = jjt + i2
+	    if (ii > 0 .and. ii <= i1 .and. jjt > 0 .and. jjt <= i2) then
+	       if (yz_mask(ii,jjt) /= 0) then
+		  yz_index(1,icount) = ii
+		  yz_index(2,icount) = jjt
+		  icount = icount + 1
+	       endif
+	    endif
+	 end do
+      endif
+
+      if (im < jc .or. (im == jc .and. mod(i2,2) /= 0)) then
+	 jj = 1-im+i2
+	 do ii=1-im+1,1+im-1
+	    iit = ii
+	    if (iit <= 0) iit = iit + i1
+	    if (iit > 0 .and. iit <= i1 .and. jj > 0 .and. jj <= i2) then
+	       if (yz_mask(iit,jj) /= 0) then
+		  yz_index(1,icount) = iit
+		  yz_index(2,icount) = jj
+		  icount = icount + 1
+	       endif
+	    endif
+	 end do
+      endif
+
+      if (im <= jc) then
+	 jj = 1+im
+	 do ii=1-im+1,1+im-1
+	    iit = ii
+	    if (iit <= 0) iit = iit + i1
+	    if (iit > 0 .and. iit <= i1 .and. jj > 0 .and. jj <= i2) then
+	       if (yz_mask(iit,jj) /= 0) then
+		  yz_index(1,icount) = iit
+		  yz_index(2,icount) = jj
+		  icount = icount + 1
+	       endif
+	    endif
+	 end do
+      endif
+
+   end do
+
+#else
+
+    i1 = SIZE ( yz_mask, 1 )
+    i2 = SIZE ( yz_mask, 2 )
+    yz_index = 0
+
+   icount = 1
+   ic=i1/2
+   jc=i2/2
+   ii=ic
+   jj=jc
+   if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+      if (yz_mask(ii,jj) /= 0) then
+	 yz_index(1,icount) = ii
+	 yz_index(2,icount) = jj
+	 icount = icount + 1
+      endif
+   endif
+   do im=1, max(ic+1,jc+1)
+      ii = ic-im
+      do jj=jc-im,jc+im
+	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+	    if (yz_mask(ii,jj) /= 0) then
+	       yz_index(1,icount) = ii
+	       yz_index(2,icount) = jj
+	       icount = icount + 1
+	    endif
+	 endif
+      end do
+      ii = ic+im
+      do jj=jc-im,jc+im
+	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+	    if (yz_mask(ii,jj) /= 0) then
+	       yz_index(1,icount) = ii
+	       yz_index(2,icount) = jj
+	       icount = icount + 1
+	    endif
+	 endif
+      end do
+      jj = jc-im
+      do ii=ic-im+1,ic+im-1
+	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+	    if (yz_mask(ii,jj) /= 0) then
+	       yz_index(1,icount) = ii
+	       yz_index(2,icount) = jj
+	       icount = icount + 1
+	    endif
+	 endif
+      end do
+      jj = jc+im
+      do ii=ic-im+1,ic+im-1
+	 if (ii > 0 .and. ii <= i1 .and. jj > 0 .and. jj <= i2) then
+	    if (yz_mask(ii,jj) /= 0) then
+	       yz_index(1,icount) = ii
+	       yz_index(2,icount) = jj
+	       icount = icount + 1
+	    endif
+	 endif
+      end do
+   end do
+
+#endif
+#endif
+
   END SUBROUTINE order_mask
 
 ! *****************************************************************************
