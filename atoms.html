<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Atoms objects &mdash; quippy  documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="quippy  documentation" href="index.html" />
    <link rel="up" title="Quippy library reference" href="quippy.html" />
    <link rel="prev" title="Quippy library reference" href="quippy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quippy.html" title="Quippy library reference"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">quippy  documentation</a> &raquo;</li>
          <li><a href="quippy.html" accesskey="U">Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/hybrid.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="quippy.html"
                        title="previous chapter">Quippy library reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/atoms.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-quippy.atoms">
<span id="atoms-objects"></span><h1>Atoms objects<a class="headerlink" href="#module-quippy.atoms" title="Permalink to this headline">Â¶</a></h1>
<p>This module defines the <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a>, which stores and manipulates a
collection of atoms, as well as the <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> class which stores
topology and neighbour lists, and the <a class="reference internal" href="domaindecomposition.html#quippy.atoms.DomainDecomposition" title="quippy.atoms.DomainDecomposition"><tt class="xref py py-class docutils literal"><span class="pre">DomainDecomposition</span></tt></a> class.</p>
<p>Module contents for <a class="reference internal" href="#module-quippy.atoms" title="quippy.atoms: Representation of atomic configurations"><tt class="xref py py-mod docutils literal"><span class="pre">quippy.atoms</span></tt></a>:</p>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-obj docutils literal"><span class="pre">Connection</span></tt></a>(...)</td>
<td>The Connection type stores the topology of a set of Atoms</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="domaindecomposition.html#quippy.atoms.DomainDecomposition" title="quippy.atoms.DomainDecomposition"><tt class="xref py py-obj docutils literal"><span class="pre">DomainDecomposition</span></tt></a>(...)</td>
<td>Initialize the domain decomposition module</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-obj docutils literal"><span class="pre">Atoms</span></tt></a>([symbols,&nbsp;positions,&nbsp;numbers,&nbsp;tags,&nbsp;...)</td>
<td>Representation of an atomic configuration and its associated properties</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">NeighbourInfo</span></tt>(j,&nbsp;distance,&nbsp;diff,&nbsp;cosines,&nbsp;shift)</td>
<td>Store information about a single neighbour of an atom</td>
</tr>
</tbody>
</table>
<p class="rubric">Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.get_lattice_params" title="quippy.atoms.get_lattice_params"><tt class="xref py py-obj docutils literal"><span class="pre">get_lattice_params</span></tt></a>(lattice)</td>
<td>Wrapper around Fortran <tt class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.make_lattice" title="quippy.atoms.make_lattice"><tt class="xref py py-obj docutils literal"><span class="pre">make_lattice</span></tt></a>(a,[b,c,alpha,beta,gamma,error])</td>
<td>Make a matrix of lattice vectors from the lengths <tt class="docutils literal"><span class="pre">a</span></tt>,``b``,``c`` and the angles <tt class="docutils literal"><span class="pre">alpha</span></tt>, <tt class="docutils literal"><span class="pre">beta</span></tt> and <tt class="docutils literal"><span class="pre">gamma</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="connection.html#quippy.atoms.divide_cell" title="quippy.atoms.divide_cell"><tt class="xref py py-obj docutils literal"><span class="pre">divide_cell</span></tt></a>(lattice,cutoff)</td>
<td>Given a simulation cell defined by lattice vectors, how many</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="connection.html#quippy.atoms.max_cutoff" title="quippy.atoms.max_cutoff"><tt class="xref py py-obj docutils literal"><span class="pre">max_cutoff</span></tt></a>(lattice,[error])</td>
<td>Returns the maximum cutoff radius for <tt class="docutils literal"><span class="pre">calc_connect</span></tt>, given the lattice if we want to avoid image neghbours</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.parse_atom_mask" title="quippy.atoms.parse_atom_mask"><tt class="xref py py-obj docutils literal"><span class="pre">parse_atom_mask</span></tt></a>(mask_in,[error])</td>
<td>Parses an atom_mask, which is string consisting of the <tt class="docutils literal"><span class="pre">&#64;</span></tt> symbol followed by a comma separated list of indices or ranges into a table containing all the indices it represents.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="connection.html#quippy.atoms.fit_box_in_cell" title="quippy.atoms.fit_box_in_cell"><tt class="xref py py-obj docutils literal"><span class="pre">fit_box_in_cell</span></tt></a>(rx,ry,rz,lattice)</td>
<td>Given an orthogonal box, oriented along the cartesian axes with lengths <tt class="docutils literal"><span class="pre">2*rx</span></tt>, <tt class="docutils literal"><span class="pre">2*ry</span></tt> and <tt class="docutils literal"><span class="pre">2*rz</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">difference</span></tt>(list1,list2,[error])</td>
<td>Return the difference between list1 and list2 in outlist.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.bond_length" title="quippy.atoms.bond_length"><tt class="xref py py-obj docutils literal"><span class="pre">bond_length</span></tt></a>(z1,z2)</td>
<td>Returns the sum of the covalent radii of two atoms</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_in_subregion</span></tt>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.termination_bond_rescale" title="quippy.atoms.termination_bond_rescale"><tt class="xref py py-obj docutils literal"><span class="pre">termination_bond_rescale</span></tt></a>(z1,z2)</td>
<td>Calculates the rescale ratio of a Z1&#8211;H bond generate from a Z1&#8211;Z2 bond.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="connection.html#quippy.atoms.get_min_max_images" title="quippy.atoms.get_min_max_images"><tt class="xref py py-obj docutils literal"><span class="pre">get_min_max_images</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.cell_volume" title="quippy.atoms.cell_volume"><tt class="xref py py-obj docutils literal"><span class="pre">cell_volume</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>calculate volume of unit cell</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.map_into_cell" title="quippy.atoms.map_into_cell"><tt class="xref py py-obj docutils literal"><span class="pre">map_into_cell</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Map atomic positions into the unit cell so that lattice</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">get_lattice_params_</span></tt>(...)</td>
<td>Opposite of Make_Lattice.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.get_lattice_params" title="quippy.atoms.get_lattice_params"><tt class="xref py py-obj docutils literal"><span class="pre">get_lattice_params</span></tt></a>(lattice)</td>
<td>Wrapper around Fortran <tt class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></tt></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table border="1" class="docutils">
<colgroup>
<col width="84%" />
<col width="16%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Value</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">DD_WRAP_TO_DOMAIN</span></tt></td>
<td>2</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-attr docutils literal"><span class="pre">NOT_NEIGHBOUR</span></tt></td>
<td>0</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">DEFAULT_NNEIGHTOL</span></tt></td>
<td>1.2</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-attr docutils literal"><span class="pre">CONNECT_LATTICE_TOL</span></tt></td>
<td>1e-08</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-attr docutils literal"><span class="pre">DD_WRAP_TO_CELL</span></tt></td>
<td>1</td>
</tr>
</tbody>
</table>
<dl class="class">
<dt id="quippy.atoms.Atoms">
<em class="property">class </em><tt class="descclassname">quippy.atoms.</tt><tt class="descname">Atoms</tt><big>(</big><span class="optional">[</span><em>symbols</em>, <em>positions</em>, <em>numbers</em>, <em>tags</em>, <em>momenta</em>, <em>masses</em>, <em>magmoms</em>, <em>charges</em>, <em>scaled_positions</em>, <em>cell</em>, <em>pbc</em>, <em>constraint</em>, <em>calculator</em>, <em>info</em>, <em>n</em>, <em>lattice</em>, <em>properties</em>, <em>params</em>, <em>fixed_size</em>, <em>**read_args</em><span class="optional">]</span><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">quippy._atoms.Atoms</span></tt>, <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/atoms.html#ase.atoms.Atoms" title="(in ASE v3.9.0.4128)"><tt class="xref py py-class docutils literal"><span class="pre">ase.atoms.Atoms</span></tt></a></p>
<p>Representation of an atomic configuration and its associated properties</p>
<p>An atoms object contains atomic numbers, all dynamical variables
and connectivity information for all the atoms in the simulation cell.
It is initialised like this:</p>
<div class="highlight-python"><div class="highlight"><pre>call initialise(MyAtoms,N,lattice)
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">N</span></tt> is the number of atoms to allocate space for and <tt class="docutils literal"><span class="pre">lattice</span></tt> is a <img class="math" src="_images/math/59ca78535a2bfd005ddf503222102c74a0199b90.png" alt="3\times3"/>
matrix of lattice vectors given as column vectors, so that <tt class="docutils literal"><span class="pre">lattice(:,i)</span></tt> is the i-th lattice vector.</p>
<p>Atoms also contains a Connection object, which stores distance information about
the atom neghbours after <tt class="docutils literal"><span class="pre">calc_connect</span></tt> has been called. Rather than using a minimum
image convention, all neighbours are stored up to a radius of <tt class="docutils literal"><span class="pre">cutoff</span></tt>, including images</p>
<p>Initialise type(Atoms), pointer objects. Shallow copies of these will
survive even if the initial declaration goes out of scope. The object will
automatically deallocate upon calling finalise_ptr when the last shallow
copy goes out of scope</p>
<p>The <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> class is a Pythonic wrapper over the auto-generated
<tt class="xref py py-class docutils literal"><span class="pre">quippy._atoms.Atoms</span></tt> class. Atoms object are usually
constructed either by reading from an input file in one of the
<a class="reference internal" href="io.html#fileformats"><em>Supported File Formats</em></a>, or by using the structure creation functions in
the <a class="reference internal" href="structures.html#module-quippy.structures" title="quippy.structures: Structure building routines"><tt class="xref py py-mod docutils literal"><span class="pre">quippy.structures</span></tt></a> or <a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/lattice.html#module-ase.lattice" title="(in ASE v3.9.0.4128)"><tt class="xref py py-mod docutils literal"><span class="pre">ase.lattice</span></tt></a> modules.</p>
<p>For example to read from an <a class="reference internal" href="io.html#extendedxyz"><em>Extended XYZ</em></a> file, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quippy.atoms</span> <span class="kn">import</span> <span class="n">Atoms</span>
<span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s">&#39;filename.xyz&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or, to create an 8-atom bulk diamond cubic cell of silicon:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">quippy.structures</span> <span class="kn">import</span> <span class="n">diamond</span>
<span class="n">si_bulk</span> <span class="o">=</span> <span class="n">diamond</span><span class="p">(</span><span class="mf">5.44</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> class is inherited from the
<a class="reference external" href="https://wiki.fysik.dtu.dk/ase/ase/atoms.html#ase.atoms.Atoms" title="(in ASE v3.9.0.4128)"><tt class="xref py py-class docutils literal"><span class="pre">ase.atoms.Atoms</span></tt></a> so has all the ASE Atoms attributes and
methods. This means that quippy and ASE Atoms objects are fully
interoperable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>n</strong> :  input int</p>
<p><strong>lattice</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<p><strong>properties</strong> : <a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> object, optional</p>
<p><strong>params</strong> : <a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> object, optional</p>
<p><strong>fixed_size</strong> :  input int, optional</p>
<p><strong>nbuffer</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">__init__initialise_ptr</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.
Class is wrapper around Fortran type <tt class="docutils literal"><span class="pre">Atoms</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
<p class="rubric">Attributes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.arrays" title="quippy.atoms.Atoms.arrays"><tt class="xref py py-obj docutils literal"><span class="pre">arrays</span></tt></a></td>
<td>Provides access to ASE arrays, stored in QUIP properties dict</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc" title="quippy.atoms.Atoms.calc"><tt class="xref py py-obj docutils literal"><span class="pre">calc</span></tt></a></td>
<td>Calculator object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.cell" title="quippy.atoms.Atoms.cell"><tt class="xref py py-obj docutils literal"><span class="pre">cell</span></tt></a></td>
<td>Attribute for direct manipulation of the unit cell.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.connect" title="quippy.atoms.Atoms.connect"><tt class="xref py py-obj docutils literal"><span class="pre">connect</span></tt></a></td>
<td><a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.constraints" title="quippy.atoms.Atoms.constraints"><tt class="xref py py-obj docutils literal"><span class="pre">constraints</span></tt></a></td>
<td>Constraints of the atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.cutoff" title="quippy.atoms.Atoms.cutoff"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff</span></tt></a></td>
<td>if <tt class="docutils literal"><span class="pre">use_uniform_cutoff</span></tt> is true, cutoff</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.cutoff_break" title="quippy.atoms.Atoms.cutoff_break"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff_break</span></tt></a></td>
<td>Cutoff length for bonds to be considered broken with hysteretic connectivity</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.cutoff_skin" title="quippy.atoms.Atoms.cutoff_skin"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff_skin</span></tt></a></td>
<td>If non-zero, increase cutoff by this amount to reduce calc_connect() frequency</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.domain" title="quippy.atoms.Atoms.domain"><tt class="xref py py-obj docutils literal"><span class="pre">domain</span></tt></a></td>
<td>Domain decomposition object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.fixed_size" title="quippy.atoms.Atoms.fixed_size"><tt class="xref py py-obj docutils literal"><span class="pre">fixed_size</span></tt></a></td>
<td>Can the number of atoms be changed after initialisation?</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.g" title="quippy.atoms.Atoms.g"><tt class="xref py py-obj docutils literal"><span class="pre">g</span></tt></a></td>
<td>Inverse lattice (stored for speed)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.hysteretic_connect" title="quippy.atoms.Atoms.hysteretic_connect"><tt class="xref py py-obj docutils literal"><span class="pre">hysteretic_connect</span></tt></a></td>
<td>Hysteretic <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.indices" title="quippy.atoms.Atoms.indices"><tt class="xref py py-obj docutils literal"><span class="pre">indices</span></tt></a></td>
<td>Return array of atoms indices</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.info" title="quippy.atoms.Atoms.info"><tt class="xref py py-obj docutils literal"><span class="pre">info</span></tt></a></td>
<td>ASE info dictionary</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.lattice" title="quippy.atoms.Atoms.lattice"><tt class="xref py py-obj docutils literal"><span class="pre">lattice</span></tt></a></td>
<td>Lattice vectors, as columns:</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.n" title="quippy.atoms.Atoms.n"><tt class="xref py py-obj docutils literal"><span class="pre">n</span></tt></a></td>
<td>The number of atoms held (including ghost particles)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.nbuffer" title="quippy.atoms.Atoms.nbuffer"><tt class="xref py py-obj docutils literal"><span class="pre">nbuffer</span></tt></a></td>
<td>The number of atoms that can be stored in the buffers of this Atoms object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.ndomain" title="quippy.atoms.Atoms.ndomain"><tt class="xref py py-obj docutils literal"><span class="pre">ndomain</span></tt></a></td>
<td>The number of atoms held by the local process (excluding ghost particles)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.nneightol" title="quippy.atoms.Atoms.nneightol"><tt class="xref py py-obj docutils literal"><span class="pre">nneightol</span></tt></a></td>
<td>Count as nearest neighbour if sum of covalent radii times <tt class="docutils literal"><span class="pre">this.nneightol</span></tt> greater than distance between atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.numbers" title="quippy.atoms.Atoms.numbers"><tt class="xref py py-obj docutils literal"><span class="pre">numbers</span></tt></a></td>
<td>Attribute for direct manipulation of the atomic numbers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.own_this" title="quippy.atoms.Atoms.own_this"><tt class="xref py py-obj docutils literal"><span class="pre">own_this</span></tt></a></td>
<td>Do I own myself?</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.params" title="quippy.atoms.Atoms.params"><tt class="xref py py-obj docutils literal"><span class="pre">params</span></tt></a></td>
<td><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> of parameters. Useful for storing data about this</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.pbc" title="quippy.atoms.Atoms.pbc"><tt class="xref py py-obj docutils literal"><span class="pre">pbc</span></tt></a></td>
<td>Attribute for direct manipulation of the periodic boundary condition flags.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.positions" title="quippy.atoms.Atoms.positions"><tt class="xref py py-obj docutils literal"><span class="pre">positions</span></tt></a></td>
<td>Attribute for direct manipulation of the positions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.properties" title="quippy.atoms.Atoms.properties"><tt class="xref py py-obj docutils literal"><span class="pre">properties</span></tt></a></td>
<td><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> of atomic properties. A property is an array</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.ref_count" title="quippy.atoms.Atoms.ref_count"><tt class="xref py py-obj docutils literal"><span class="pre">ref_count</span></tt></a></td>
<td>Reference counter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.use_uniform_cutoff" title="quippy.atoms.Atoms.use_uniform_cutoff"><tt class="xref py py-obj docutils literal"><span class="pre">use_uniform_cutoff</span></tt></a></td>
<td>Rather than covalent radii &#8212; default is variable cutoff.</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.add_atoms" title="quippy.atoms.Atoms.add_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">add_atoms</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Add one or more atoms to an Atoms object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.add_cut_hydrogens" title="quippy.atoms.Atoms.add_cut_hydrogens"><tt class="xref py py-obj docutils literal"><span class="pre">add_cut_hydrogens</span></tt></a>(...)</td>
<td>Given an atoms structure and a list of quantum atoms, find X-H bonds which have been cut and include the other atom of the pair in the quantum list.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.add_property" title="quippy.atoms.Atoms.add_property"><tt class="xref py py-obj docutils literal"><span class="pre">add_property</span></tt></a>(name,&nbsp;value[,&nbsp;n_cols,&nbsp;...])</td>
<td>Add a new property to this Atoms object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.add_property_from_pointer" title="quippy.atoms.Atoms.add_property_from_pointer"><tt class="xref py py-obj docutils literal"><span class="pre">add_property_from_pointer</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Add a per-atom property to this atoms object, but point to existing space rather than allocating new space for it (as add_property does).</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.angular_momentum" title="quippy.atoms.Atoms.angular_momentum"><tt class="xref py py-obj docutils literal"><span class="pre">angular_momentum</span></tt></a>([origin,indices])</td>
<td>Return the angular momentum of all the atoms in this DynamicalSystem, defined by <img class="math" src="_images/math/ede2d8f94fbc6c451abbbe27d607904bcef7f7c0.png" alt="\mathbf{L} = \sum_{i} \mathbf{r_i} \times \mathbf{v_i}"/>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.append" title="quippy.atoms.Atoms.append"><tt class="xref py py-obj docutils literal"><span class="pre">append</span></tt></a>(atom)</td>
<td>Append atom to end.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.assignment" title="quippy.atoms.Atoms.assignment"><tt class="xref py py-obj docutils literal"><span class="pre">assignment</span></tt></a>(to,from)</td>
<td>Overloaded assigment operators for Atoms objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.bfs_grow_list" title="quippy.atoms.Atoms.bfs_grow_list"><tt class="xref py py-obj docutils literal"><span class="pre">bfs_grow_list</span></tt></a>(...)</td>
<td>On exit, <tt class="docutils literal"><span class="pre">list</span></tt> will have been grown by <tt class="docutils literal"><span class="pre">n</span></tt> bond hops.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.bfs_grow_single" title="quippy.atoms.Atoms.bfs_grow_single"><tt class="xref py py-obj docutils literal"><span class="pre">bfs_grow_single</span></tt></a>(...)</td>
<td>On exit, <tt class="docutils literal"><span class="pre">list</span></tt> will contain <tt class="docutils literal"><span class="pre">atom</span></tt> (with shift <tt class="docutils literal"><span class="pre">000</span></tt>) plus the atoms within <tt class="docutils literal"><span class="pre">n</span></tt> bonds hops of it.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.bfs_step" title="quippy.atoms.Atoms.bfs_step"><tt class="xref py py-obj docutils literal"><span class="pre">bfs_step</span></tt></a>(...)</td>
<td>Execute one Breadth-First-Search move on the atomic connectivity graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_connect" title="quippy.atoms.Atoms.calc_connect"><tt class="xref py py-obj docutils literal"><span class="pre">calc_connect</span></tt></a>(...)</td>
<td>Fast <img class="math" src="_images/math/4d51d3f476c76dc066b26271168bc3b67f49d2be.png" alt="O(N)"/> connectivity calculation routine.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_connect_hysteretic" title="quippy.atoms.Atoms.calc_connect_hysteretic"><tt class="xref py py-obj docutils literal"><span class="pre">calc_connect_hysteretic</span></tt></a>(...)</td>
<td>As for <tt class="docutils literal"><span class="pre">calc_connect</span></tt>, but perform the connectivity update hystertically: atoms must come within <tt class="docutils literal"><span class="pre">cutoff</span></tt> to be considered neighbours, and then will remain connect until them move apart further than <tt class="docutils literal"><span class="pre">cutoff_break</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_dists" title="quippy.atoms.Atoms.calc_dists"><tt class="xref py py-obj docutils literal"><span class="pre">calc_dists</span></tt></a>([alt_connect,parallel,error])</td>
<td>Update stored distance tables.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_msd" title="quippy.atoms.Atoms.calc_msd"><tt class="xref py py-obj docutils literal"><span class="pre">calc_msd</span></tt></a>(at,[mask,reset_msd,persistent])</td>
<td>calculate mean squared displacement, with or without persistent atoms object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_qw" title="quippy.atoms.Atoms.calc_qw"><tt class="xref py py-obj docutils literal"><span class="pre">calc_qw</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.calc_qw_grad" title="quippy.atoms.Atoms.calc_qw_grad"><tt class="xref py py-obj docutils literal"><span class="pre">calc_qw_grad</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.cell_volume" title="quippy.atoms.Atoms.cell_volume"><tt class="xref py py-obj docutils literal"><span class="pre">cell_volume</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>atoms_cell_volume</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.center" title="quippy.atoms.Atoms.center"><tt class="xref py py-obj docutils literal"><span class="pre">center</span></tt></a>([vacuum,&nbsp;axis])</td>
<td>Center atoms in unit cell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.centre_of_mass" title="quippy.atoms.Atoms.centre_of_mass"><tt class="xref py py-obj docutils literal"><span class="pre">centre_of_mass</span></tt></a>(at,[index_list,mask,origin,error])</td>
<td>Calculate the centre of mass of an atoms object, using the closest images to the origin atom, or first atom if this is not specified.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.closest_atom" title="quippy.atoms.Atoms.closest_atom"><tt class="xref py py-obj docutils literal"><span class="pre">closest_atom</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.coalesce_in_one_periodic_image" title="quippy.atoms.Atoms.coalesce_in_one_periodic_image"><tt class="xref py py-obj docutils literal"><span class="pre">coalesce_in_one_periodic_image</span></tt></a>(...)</td>
<td>move atoms around following neighbor list bonds so that all are in the same periodic image</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.complement" title="quippy.atoms.Atoms.complement"><tt class="xref py py-obj docutils literal"><span class="pre">complement</span></tt></a>(at,inlist)</td>
<td>Return the complement of a list, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy" title="quippy.atoms.Atoms.copy"><tt class="xref py py-obj docutils literal"><span class="pre">copy</span></tt></a>()</td>
<td>Return a copy of this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy_entry" title="quippy.atoms.Atoms.copy_entry"><tt class="xref py py-obj docutils literal"><span class="pre">copy_entry</span></tt></a>(src,dst,[swap,error])</td>
<td>Copy an atom to a different index Move a single atom from one location to another one.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy_from" title="quippy.atoms.Atoms.copy_from"><tt class="xref py py-obj docutils literal"><span class="pre">copy_from</span></tt></a>(other)</td>
<td>Replace contents of this Atoms object with data from <cite>other</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy_properties" title="quippy.atoms.Atoms.copy_properties"><tt class="xref py py-obj docutils literal"><span class="pre">copy_properties</span></tt></a>(...)</td>
<td>Copy some properties from one atoms struct to another The destination will be overriden.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.copy_without_connect" title="quippy.atoms.Atoms.copy_without_connect"><tt class="xref py py-obj docutils literal"><span class="pre">copy_without_connect</span></tt></a>(...)</td>
<td>Make a copy of the atoms object <tt class="docutils literal"><span class="pre">from</span></tt> without including connectivity information.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.cosine" title="quippy.atoms.Atoms.cosine"><tt class="xref py py-obj docutils literal"><span class="pre">cosine</span></tt></a>(i,j,k,[error])</td>
<td>Cosine of the angle j&#8211;i&#8211;k</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.cosine_neighbour" title="quippy.atoms.Atoms.cosine_neighbour"><tt class="xref py py-obj docutils literal"><span class="pre">cosine_neighbour</span></tt></a>(i,n,m)</td>
<td>Cosine of the angle n&#8211;i&#8211;m where {<img class="math" src="_images/math/64b057f2648659ddd229341cecdae58d08751849.png" alt="n,m"/>} are the {:math:<a href="#id1"><span class="problematic" id="id2">`</span></a>n`th, :math:<a href="#id3"><span class="problematic" id="id4">`</span></a>m`th} neighbours of i</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.cutoff_" title="quippy.atoms.Atoms.cutoff_"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff_</span></tt></a>(z1,z2)</td>
<td>Return cutoff used for bonds of type Z1&#8211;Z2 Return the actual cutoff in AA{} used by this atoms object used to form <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bonds.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.cutoff_break_" title="quippy.atoms.Atoms.cutoff_break_"><tt class="xref py py-obj docutils literal"><span class="pre">cutoff_break_</span></tt></a>(z1,z2)</td>
<td>Return cutoff_break used for bonds of type Z1&#8211;Z2 Return the actual cutoff in AA{} used by this atoms object used to break <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bonds.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.density" title="quippy.atoms.Atoms.density"><tt class="xref py py-obj docutils literal"><span class="pre">density</span></tt></a>()</td>
<td>Density in units of <img class="math" src="_images/math/846ffd8410b4e884443d8b7f2df37cc417186f4c.png" alt="g/m^3"/>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.diff" title="quippy.atoms.Atoms.diff"><tt class="xref py py-obj docutils literal"><span class="pre">diff</span></tt></a>(i,j,shift)</td>
<td>Difference vector between atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> if they are separated by a shift of <tt class="docutils literal"><span class="pre">shift</span></tt></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.diff_min_image" title="quippy.atoms.Atoms.diff_min_image"><tt class="xref py py-obj docutils literal"><span class="pre">diff_min_image</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Return the minimum image difference vector between two atoms or  positions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.direction_cosines" title="quippy.atoms.Atoms.direction_cosines"><tt class="xref py py-obj docutils literal"><span class="pre">direction_cosines</span></tt></a>(i,j,shift)</td>
<td>Given two atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> and a shift returns the direction cosines of the differnece vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.direction_cosines_min_image" title="quippy.atoms.Atoms.direction_cosines_min_image"><tt class="xref py py-obj docutils literal"><span class="pre">direction_cosines_min_image</span></tt></a>(i,j,[error])</td>
<td>Direction cosines of the difference vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.directionality" title="quippy.atoms.Atoms.directionality"><tt class="xref py py-obj docutils literal"><span class="pre">directionality</span></tt></a>(origin,list,[method,error])</td>
<td>Given an origin atom and a list of other atoms, give information as to whether the other atoms are distributed roughly linearly, planar or spherically around the origin atom.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.distance" title="quippy.atoms.Atoms.distance"><tt class="xref py py-obj docutils literal"><span class="pre">distance</span></tt></a>(i,j,shift)</td>
<td>Return distance between atoms <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> if they are separated by a shift of <tt class="docutils literal"><span class="pre">shift</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.distance_min_image" title="quippy.atoms.Atoms.distance_min_image"><tt class="xref py py-obj docutils literal"><span class="pre">distance_min_image</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>This interface calculates the distance between the nearest periodic images of two points (or atoms).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.edit" title="quippy.atoms.Atoms.edit"><tt class="xref py py-obj docutils literal"><span class="pre">edit</span></tt></a>()</td>
<td>Modify atoms interactively through ase-gui viewer.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.equivalent" title="quippy.atoms.Atoms.equivalent"><tt class="xref py py-obj docutils literal"><span class="pre">equivalent</span></tt></a>(other)</td>
<td>Test for equivalence of two Atoms objects.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.extend" title="quippy.atoms.Atoms.extend"><tt class="xref py py-obj docutils literal"><span class="pre">extend</span></tt></a>(other)</td>
<td>Extend atoms object by appending atoms from <em>other</em>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.fake_smooth_pos" title="quippy.atoms.Atoms.fake_smooth_pos"><tt class="xref py py-obj docutils literal"><span class="pre">fake_smooth_pos</span></tt></a>(at,mix,[persistent])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_all_distances" title="quippy.atoms.Atoms.get_all_distances"><tt class="xref py py-obj docutils literal"><span class="pre">get_all_distances</span></tt></a>([mic])</td>
<td>Return distances of all of the atoms with all of the atoms.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_angle" title="quippy.atoms.Atoms.get_angle"><tt class="xref py py-obj docutils literal"><span class="pre">get_angle</span></tt></a>(list)</td>
<td>Get angle formed by three atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_angular_momentum" title="quippy.atoms.Atoms.get_angular_momentum"><tt class="xref py py-obj docutils literal"><span class="pre">get_angular_momentum</span></tt></a>()</td>
<td>Get total angular momentum with respect to the center of mass.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_array" title="quippy.atoms.Atoms.get_array"><tt class="xref py py-obj docutils literal"><span class="pre">get_array</span></tt></a>(name[,&nbsp;copy])</td>
<td>Get an array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_atom" title="quippy.atoms.Atoms.get_atom"><tt class="xref py py-obj docutils literal"><span class="pre">get_atom</span></tt></a>(i)</td>
<td>Return a dictionary containing the properties of the atom with index <cite>i</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_atomic_numbers" title="quippy.atoms.Atoms.get_atomic_numbers"><tt class="xref py py-obj docutils literal"><span class="pre">get_atomic_numbers</span></tt></a>()</td>
<td>Get integer array of atomic numbers.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_calculation_done" title="quippy.atoms.Atoms.get_calculation_done"><tt class="xref py py-obj docutils literal"><span class="pre">get_calculation_done</span></tt></a>()</td>
<td>Let the calculator calculate its thing, using the current input.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_calculator" title="quippy.atoms.Atoms.get_calculator"><tt class="xref py py-obj docutils literal"><span class="pre">get_calculator</span></tt></a>()</td>
<td>Get currently attached calculator object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_cell" title="quippy.atoms.Atoms.get_cell"><tt class="xref py py-obj docutils literal"><span class="pre">get_cell</span></tt></a>()</td>
<td>Get the three unit cell vectors as a 3x3 ndarray.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_celldisp" title="quippy.atoms.Atoms.get_celldisp"><tt class="xref py py-obj docutils literal"><span class="pre">get_celldisp</span></tt></a>()</td>
<td>Get the unit cell displacement vectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_center_of_mass" title="quippy.atoms.Atoms.get_center_of_mass"><tt class="xref py py-obj docutils literal"><span class="pre">get_center_of_mass</span></tt></a>([scaled])</td>
<td>Get the center of mass.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_charges" title="quippy.atoms.Atoms.get_charges"><tt class="xref py py-obj docutils literal"><span class="pre">get_charges</span></tt></a>()</td>
<td>Get calculated charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_chemical_formula" title="quippy.atoms.Atoms.get_chemical_formula"><tt class="xref py py-obj docutils literal"><span class="pre">get_chemical_formula</span></tt></a>([mode])</td>
<td>Get the chemial formula as a string based on the chemical symbols.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_chemical_symbols" title="quippy.atoms.Atoms.get_chemical_symbols"><tt class="xref py py-obj docutils literal"><span class="pre">get_chemical_symbols</span></tt></a>()</td>
<td>Get list of chemical symbol strings.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_dihedral" title="quippy.atoms.Atoms.get_dihedral"><tt class="xref py py-obj docutils literal"><span class="pre">get_dihedral</span></tt></a>(list)</td>
<td>Calculate dihedral angle.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_dipole_moment" title="quippy.atoms.Atoms.get_dipole_moment"><tt class="xref py py-obj docutils literal"><span class="pre">get_dipole_moment</span></tt></a>()</td>
<td>Calculate the electric dipole moment for the atoms object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_distance" title="quippy.atoms.Atoms.get_distance"><tt class="xref py py-obj docutils literal"><span class="pre">get_distance</span></tt></a>(a0,&nbsp;a1[,&nbsp;mic,&nbsp;vector])</td>
<td>Return distance between two atoms.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_distances" title="quippy.atoms.Atoms.get_distances"><tt class="xref py py-obj docutils literal"><span class="pre">get_distances</span></tt></a>(a,&nbsp;indices[,&nbsp;mic,&nbsp;vector])</td>
<td>Return distances of atom No.i with a list of atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_forces" title="quippy.atoms.Atoms.get_forces"><tt class="xref py py-obj docutils literal"><span class="pre">get_forces</span></tt></a>([apply_constraint])</td>
<td>Calculate atomic forces.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_initial_charges" title="quippy.atoms.Atoms.get_initial_charges"><tt class="xref py py-obj docutils literal"><span class="pre">get_initial_charges</span></tt></a>()</td>
<td>Get array of initial charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_initial_magnetic_moments" title="quippy.atoms.Atoms.get_initial_magnetic_moments"><tt class="xref py py-obj docutils literal"><span class="pre">get_initial_magnetic_moments</span></tt></a>()</td>
<td>Get array of initial magnetic moments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_kinetic_energy" title="quippy.atoms.Atoms.get_kinetic_energy"><tt class="xref py py-obj docutils literal"><span class="pre">get_kinetic_energy</span></tt></a>()</td>
<td>Get the kinetic energy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_magnetic_moment" title="quippy.atoms.Atoms.get_magnetic_moment"><tt class="xref py py-obj docutils literal"><span class="pre">get_magnetic_moment</span></tt></a>()</td>
<td>Get calculated total magnetic moment.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_magnetic_moments" title="quippy.atoms.Atoms.get_magnetic_moments"><tt class="xref py py-obj docutils literal"><span class="pre">get_magnetic_moments</span></tt></a>()</td>
<td>Get calculated local magnetic moments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_masses" title="quippy.atoms.Atoms.get_masses"><tt class="xref py py-obj docutils literal"><span class="pre">get_masses</span></tt></a>()</td>
<td>Get array of masses.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_momenta" title="quippy.atoms.Atoms.get_momenta"><tt class="xref py py-obj docutils literal"><span class="pre">get_momenta</span></tt></a>()</td>
<td>Get array of momenta.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_moments_of_inertia" title="quippy.atoms.Atoms.get_moments_of_inertia"><tt class="xref py py-obj docutils literal"><span class="pre">get_moments_of_inertia</span></tt></a>([vectors])</td>
<td>Get the moments of inertia along the principal axes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_number_of_atoms" title="quippy.atoms.Atoms.get_number_of_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">get_number_of_atoms</span></tt></a>()</td>
<td>Returns the number of atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_param_value" title="quippy.atoms.Atoms.get_param_value"><tt class="xref py py-obj docutils literal"><span class="pre">get_param_value</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>get a (per-configuration) value from the atoms%params dictionary</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_pbc" title="quippy.atoms.Atoms.get_pbc"><tt class="xref py py-obj docutils literal"><span class="pre">get_pbc</span></tt></a>()</td>
<td>Get periodic boundary condition flags.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_positions" title="quippy.atoms.Atoms.get_positions"><tt class="xref py py-obj docutils literal"><span class="pre">get_positions</span></tt></a>([wrap])</td>
<td>Get array of positions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_potential_energies" title="quippy.atoms.Atoms.get_potential_energies"><tt class="xref py py-obj docutils literal"><span class="pre">get_potential_energies</span></tt></a>()</td>
<td>Calculate the potential energies of all the atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_potential_energy" title="quippy.atoms.Atoms.get_potential_energy"><tt class="xref py py-obj docutils literal"><span class="pre">get_potential_energy</span></tt></a>([force_consistent,&nbsp;...])</td>
<td>Calculate potential energy.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_reciprocal_cell" title="quippy.atoms.Atoms.get_reciprocal_cell"><tt class="xref py py-obj docutils literal"><span class="pre">get_reciprocal_cell</span></tt></a>()</td>
<td>Get the three reciprocal lattice vectors as a 3x3 ndarray.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_scaled_positions" title="quippy.atoms.Atoms.get_scaled_positions"><tt class="xref py py-obj docutils literal"><span class="pre">get_scaled_positions</span></tt></a>()</td>
<td>Get positions relative to unit cell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_stress" title="quippy.atoms.Atoms.get_stress"><tt class="xref py py-obj docutils literal"><span class="pre">get_stress</span></tt></a>([voigt])</td>
<td>Calculate stress tensor.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_stresses" title="quippy.atoms.Atoms.get_stresses"><tt class="xref py py-obj docutils literal"><span class="pre">get_stresses</span></tt></a>()</td>
<td>Calculate the stress-tensor of all the atoms.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_tags" title="quippy.atoms.Atoms.get_tags"><tt class="xref py py-obj docutils literal"><span class="pre">get_tags</span></tt></a>()</td>
<td>Get integer array of tags.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_temperature" title="quippy.atoms.Atoms.get_temperature"><tt class="xref py py-obj docutils literal"><span class="pre">get_temperature</span></tt></a>()</td>
<td>Get the temperature in Kelvin.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_total_energy" title="quippy.atoms.Atoms.get_total_energy"><tt class="xref py py-obj docutils literal"><span class="pre">get_total_energy</span></tt></a>()</td>
<td>Get the total energy - potential plus kinetic energy.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_velocities" title="quippy.atoms.Atoms.get_velocities"><tt class="xref py py-obj docutils literal"><span class="pre">get_velocities</span></tt></a>()</td>
<td>Get array of velocities.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.get_volume" title="quippy.atoms.Atoms.get_volume"><tt class="xref py py-obj docutils literal"><span class="pre">get_volume</span></tt></a>()</td>
<td>Get volume of unit cell.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.has" title="quippy.atoms.Atoms.has"><tt class="xref py py-obj docutils literal"><span class="pre">has</span></tt></a>(name)</td>
<td>Check for existence of array.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.has_property" title="quippy.atoms.Atoms.has_property"><tt class="xref py py-obj docutils literal"><span class="pre">has_property</span></tt></a>(name)</td>
<td>Convenience function to test if a property is present.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.index_to_z_index" title="quippy.atoms.Atoms.index_to_z_index"><tt class="xref py py-obj docutils literal"><span class="pre">index_to_z_index</span></tt></a>(index)</td>
<td>Convert from a single index in range 1..this.N to a CASTEP-style (element, index) pair</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.is_domain_decomposed" title="quippy.atoms.Atoms.is_domain_decomposed"><tt class="xref py py-obj docutils literal"><span class="pre">is_domain_decomposed</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>atoms_is_domain_decomposed</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.is_initialised" title="quippy.atoms.Atoms.is_initialised"><tt class="xref py py-obj docutils literal"><span class="pre">is_initialised</span></tt></a>()</td>
<td>Is this atoms object initialised?</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.is_min_image" title="quippy.atoms.Atoms.is_min_image"><tt class="xref py py-obj docutils literal"><span class="pre">is_min_image</span></tt></a>(i,[alt_connect,error])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.is_nearest_neighbour" title="quippy.atoms.Atoms.is_nearest_neighbour"><tt class="xref py py-obj docutils literal"><span class="pre">is_nearest_neighbour</span></tt></a>(i,n,[alt_connect])</td>
<td>Test if an atom&#8217;s :math:<a href="#id5"><span class="problematic" id="id6">`</span></a>n`th neighbour is one if its nearest neighbours</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.is_nearest_neighbour_abs_index" title="quippy.atoms.Atoms.is_nearest_neighbour_abs_index"><tt class="xref py py-obj docutils literal"><span class="pre">is_nearest_neighbour_abs_index</span></tt></a>(i,j,[alt_connect])</td>
<td>Test if an atom <tt class="docutils literal"><span class="pre">j</span></tt> is one of <a href="#id7"><span class="problematic" id="id8">``</span></a>i``s nearest neighbours</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">is_same_fortran_object</span></tt>(other)</td>
<td>Test if <cite>self</cite> and <cite>other</cite> point to the same Fortan object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.iteratoms" title="quippy.atoms.Atoms.iteratoms"><tt class="xref py py-obj docutils literal"><span class="pre">iteratoms</span></tt></a>()</td>
<td>Iterate over atoms, calling get_atom() for each one</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.kinetic_energy" title="quippy.atoms.Atoms.kinetic_energy"><tt class="xref py py-obj docutils literal"><span class="pre">kinetic_energy</span></tt></a>([mpi_obj,local_ke,error])</td>
<td>Return the total kinetic energy <img class="math" src="_images/math/e74031185d07cfd0bd1566be386399a316a9e624.png" alt="E_k = \sum_{i} \frac{1}{2} m v^2"/></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.kinetic_virial" title="quippy.atoms.Atoms.kinetic_virial"><tt class="xref py py-obj docutils literal"><span class="pre">kinetic_virial</span></tt></a>([mpi_obj,error])</td>
<td>Return the total kinetic virial <img class="math" src="_images/math/f394c2f44d750bbad26ca9b3257ec68688ac24d6.png" alt="w_ij = \sum_{k} \frac{1}{2} m v_i v_j"/></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.list_matching_prop" title="quippy.atoms.Atoms.list_matching_prop"><tt class="xref py py-obj docutils literal"><span class="pre">list_matching_prop</span></tt></a>(at,list,name,value,[error])</td>
<td>Find atoms which have integer property <tt class="docutils literal"><span class="pre">prop</span></tt> with value <tt class="docutils literal"><span class="pre">value</span></tt> and return them in a table <tt class="docutils literal"><span class="pre">list</span></tt>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.make_convex" title="quippy.atoms.Atoms.make_convex"><tt class="xref py py-obj docutils literal"><span class="pre">make_convex</span></tt></a>(list)</td>
<td>Add atoms to <tt class="docutils literal"><span class="pre">list</span></tt> to make the selection region convex, i.e.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.map_into_cell" title="quippy.atoms.Atoms.map_into_cell"><tt class="xref py py-obj docutils literal"><span class="pre">map_into_cell</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>atoms_map_into_cell</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.mark_cylinder" title="quippy.atoms.Atoms.mark_cylinder"><tt class="xref py py-obj docutils literal"><span class="pre">mark_cylinder</span></tt></a>(...)</td>
<td>Mark atoms in a cylinder centred on the point <cite>p</cite> with axis <cite>v</cite> and radius <cite>r</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.mark_sphere" title="quippy.atoms.Atoms.mark_sphere"><tt class="xref py py-obj docutils literal"><span class="pre">mark_sphere</span></tt></a>(...)</td>
<td>Mark atoms in a cylinder centred on the point <cite>p</cite> with radius <cite>r</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.md5_hash" title="quippy.atoms.Atoms.md5_hash"><tt class="xref py py-obj docutils literal"><span class="pre">md5_hash</span></tt></a>(ndigits)</td>
<td>Hash an atoms object with a precision of ndigits decimal digits.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.mem_estimate" title="quippy.atoms.Atoms.mem_estimate"><tt class="xref py py-obj docutils literal"><span class="pre">mem_estimate</span></tt></a>()</td>
<td>Estimate memory usage of this Atoms object, in bytes</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.moment_of_inertia_tensor" title="quippy.atoms.Atoms.moment_of_inertia_tensor"><tt class="xref py py-obj docutils literal"><span class="pre">moment_of_inertia_tensor</span></tt></a>([origin])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.momentum" title="quippy.atoms.Atoms.momentum"><tt class="xref py py-obj docutils literal"><span class="pre">momentum</span></tt></a>([indices])</td>
<td>Return the total momentum <img class="math" src="_images/math/f65d5abc743368c153c92e6f5062a4127a165b1c.png" alt="\mathbf{p} = \sum_i \mathbf{m_i} \mathbf{v_i}"/>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.n_neighbours" title="quippy.atoms.Atoms.n_neighbours"><tt class="xref py py-obj docutils literal"><span class="pre">n_neighbours</span></tt></a>(...)</td>
<td>Neighbour list stuff Return the number of neighbour that atom <tt class="docutils literal"><span class="pre">i</span></tt> has.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.neighbour" title="quippy.atoms.Atoms.neighbour"><tt class="xref py py-obj docutils literal"><span class="pre">neighbour</span></tt></a>(...)</td>
<td>Return the index of the <img class="math" src="_images/math/564e1690873cb931ec03c3bf1ebb71b1be229940.png" alt="n^{\mbox{\small{th}}}"/> neighbour of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.pop" title="quippy.atoms.Atoms.pop"><tt class="xref py py-obj docutils literal"><span class="pre">pop</span></tt></a>([i])</td>
<td>Remove and return atom at index <em>i</em> (default last).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.print_" title="quippy.atoms.Atoms.print_"><tt class="xref py py-obj docutils literal"><span class="pre">print_</span></tt></a>([file,error])</td>
<td>Print a verbose textual description of an Atoms object to the default logger or to a specificied Inoutput object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.print_atom" title="quippy.atoms.Atoms.print_atom"><tt class="xref py py-obj docutils literal"><span class="pre">print_atom</span></tt></a>(i)</td>
<td>Pretty-print the properties of the atom with index <cite>i</cite></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.prop_names_string" title="quippy.atoms.Atoms.prop_names_string"><tt class="xref py py-obj docutils literal"><span class="pre">prop_names_string</span></tt></a>([with_types,error])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.rattle" title="quippy.atoms.Atoms.rattle"><tt class="xref py py-obj docutils literal"><span class="pre">rattle</span></tt></a>([stdev,&nbsp;seed])</td>
<td>Randomly displace atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.read" title="quippy.atoms.Atoms.read"><tt class="xref py py-obj docutils literal"><span class="pre">read</span></tt></a>(source[,&nbsp;format])</td>
<td>Class method to read Atoms object from file <cite>source</cite> according to <cite>format</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.read_cinoutput" title="quippy.atoms.Atoms.read_cinoutput"><tt class="xref py py-obj docutils literal"><span class="pre">read_cinoutput</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.read_from" title="quippy.atoms.Atoms.read_from"><tt class="xref py py-obj docutils literal"><span class="pre">read_from</span></tt></a>(source,&nbsp;**readargs)</td>
<td>Replace contents of this Atoms object with Atoms read from <cite>source</cite></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.realpos" title="quippy.atoms.Atoms.realpos"><tt class="xref py py-obj docutils literal"><span class="pre">realpos</span></tt></a>(i)</td>
<td>Return the real position of atom <tt class="docutils literal"><span class="pre">i</span></tt>, taking into account the stored travel across the periodic boundary conditions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.remove_atoms" title="quippy.atoms.Atoms.remove_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">remove_atoms</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Remove one or more atoms from an Atoms object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.remove_property" title="quippy.atoms.Atoms.remove_property"><tt class="xref py py-obj docutils literal"><span class="pre">remove_property</span></tt></a>(name,[error])</td>
<td>Remove a property from this atoms object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.repeat" title="quippy.atoms.Atoms.repeat"><tt class="xref py py-obj docutils literal"><span class="pre">repeat</span></tt></a>(rep)</td>
<td>Create new repeated atoms object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.repoint" title="quippy.atoms.Atoms.repoint"><tt class="xref py py-obj docutils literal"><span class="pre">repoint</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>OMIT</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.rotate" title="quippy.atoms.Atoms.rotate"><tt class="xref py py-obj docutils literal"><span class="pre">rotate</span></tt></a>(axis,angle,[rank1,rank2])</td>
<td>Rotate this Atoms object, transforming all rank 1 and rank 2 tensors parameters and properties</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.rotate_dihedral" title="quippy.atoms.Atoms.rotate_dihedral"><tt class="xref py py-obj docutils literal"><span class="pre">rotate_dihedral</span></tt></a>(list,&nbsp;angle[,&nbsp;mask])</td>
<td>Rotate dihedral angle.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.rotate_euler" title="quippy.atoms.Atoms.rotate_euler"><tt class="xref py py-obj docutils literal"><span class="pre">rotate_euler</span></tt></a>([center,&nbsp;phi,&nbsp;theta,&nbsp;psi])</td>
<td>Rotate atoms via Euler angles.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.select" title="quippy.atoms.Atoms.select"><tt class="xref py py-obj docutils literal"><span class="pre">select</span></tt></a>([mask,&nbsp;list,&nbsp;orig_index])</td>
<td>Return a new <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> containing a subset of the atoms in this Atoms object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_angle" title="quippy.atoms.Atoms.set_angle"><tt class="xref py py-obj docutils literal"><span class="pre">set_angle</span></tt></a>(list,&nbsp;angle[,&nbsp;mask])</td>
<td>Set angle formed by three atoms.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_array" title="quippy.atoms.Atoms.set_array"><tt class="xref py py-obj docutils literal"><span class="pre">set_array</span></tt></a>(name,&nbsp;a[,&nbsp;dtype,&nbsp;shape])</td>
<td>Update array.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_atomic_numbers" title="quippy.atoms.Atoms.set_atomic_numbers"><tt class="xref py py-obj docutils literal"><span class="pre">set_atomic_numbers</span></tt></a>(numbers)</td>
<td>Set atomic numbers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_atoms" title="quippy.atoms.Atoms.set_atoms"><tt class="xref py py-obj docutils literal"><span class="pre">set_atoms</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>Set atomic numbers (in the &#8216;z&#8217; integer property), species names  (in &#8216;species&#8217; string property) and optionally masses (if &#8216;mass&#8217;  property exists in the Atoms object).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_calculator" title="quippy.atoms.Atoms.set_calculator"><tt class="xref py py-obj docutils literal"><span class="pre">set_calculator</span></tt></a>([calc])</td>
<td>Attach calculator object.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_cell" title="quippy.atoms.Atoms.set_cell"><tt class="xref py py-obj docutils literal"><span class="pre">set_cell</span></tt></a>(cell[,&nbsp;scale_atoms,&nbsp;fix])</td>
<td>Set unit cell vectors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_celldisp" title="quippy.atoms.Atoms.set_celldisp"><tt class="xref py py-obj docutils literal"><span class="pre">set_celldisp</span></tt></a>(celldisp)</td>
<td>Set the unit cell displacement vectors.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_chemical_symbols" title="quippy.atoms.Atoms.set_chemical_symbols"><tt class="xref py py-obj docutils literal"><span class="pre">set_chemical_symbols</span></tt></a>(symbols)</td>
<td>Set chemical symbols.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_comm_property" title="quippy.atoms.Atoms.set_comm_property"><tt class="xref py py-obj docutils literal"><span class="pre">set_comm_property</span></tt></a>(...)</td>
<td>Set which properties to communicate when comm_atoms:   Communicate when atom is moved to different domain.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_constraint" title="quippy.atoms.Atoms.set_constraint"><tt class="xref py py-obj docutils literal"><span class="pre">set_constraint</span></tt></a>([constraint])</td>
<td>Apply one or more constrains.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_cutoff" title="quippy.atoms.Atoms.set_cutoff"><tt class="xref py py-obj docutils literal"><span class="pre">set_cutoff</span></tt></a>(cutoff,[cutoff_break,cutoff_skin])</td>
<td>set (a uniform) cutoff</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_cutoff_factor" title="quippy.atoms.Atoms.set_cutoff_factor"><tt class="xref py py-obj docutils literal"><span class="pre">set_cutoff_factor</span></tt></a>(factor,[factor_break])</td>
<td>set cutoff factor</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_cutoff_minimum" title="quippy.atoms.Atoms.set_cutoff_minimum"><tt class="xref py py-obj docutils literal"><span class="pre">set_cutoff_minimum</span></tt></a>(cutoff,[cutoff_break])</td>
<td>increase cutoff</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_dihedral" title="quippy.atoms.Atoms.set_dihedral"><tt class="xref py py-obj docutils literal"><span class="pre">set_dihedral</span></tt></a>(list,&nbsp;angle[,&nbsp;mask])</td>
<td>Set the dihedral angle between vectors list[0]-&gt;list[1] and list[2]-&gt;list[3] by changing the atom indexed by list[3] if mask is not None, all the atoms described in mask (read: the entire subgroup) are moved.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_distance" title="quippy.atoms.Atoms.set_distance"><tt class="xref py py-obj docutils literal"><span class="pre">set_distance</span></tt></a>(a0,&nbsp;a1,&nbsp;distance[,&nbsp;fix,&nbsp;mic])</td>
<td>Set the distance between two atoms.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_initial_charges" title="quippy.atoms.Atoms.set_initial_charges"><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_charges</span></tt></a>([charges])</td>
<td>Set the initial charges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_initial_magnetic_moments" title="quippy.atoms.Atoms.set_initial_magnetic_moments"><tt class="xref py py-obj docutils literal"><span class="pre">set_initial_magnetic_moments</span></tt></a>([magmoms])</td>
<td>Set the initial magnetic moments.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_lattice" title="quippy.atoms.Atoms.set_lattice"><tt class="xref py py-obj docutils literal"><span class="pre">set_lattice</span></tt></a>(lattice[,&nbsp;scale_positions])</td>
<td>Change the lattice vectors, keeping the inverse lattice vectors up to date.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_map_shift" title="quippy.atoms.Atoms.set_map_shift"><tt class="xref py py-obj docutils literal"><span class="pre">set_map_shift</span></tt></a>([error])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_masses" title="quippy.atoms.Atoms.set_masses"><tt class="xref py py-obj docutils literal"><span class="pre">set_masses</span></tt></a>([masses])</td>
<td>Set atomic masses.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_momenta" title="quippy.atoms.Atoms.set_momenta"><tt class="xref py py-obj docutils literal"><span class="pre">set_momenta</span></tt></a>(momenta)</td>
<td>Set momenta.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_param_value" title="quippy.atoms.Atoms.set_param_value"><tt class="xref py py-obj docutils literal"><span class="pre">set_param_value</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>set a (per-configuration) value from the atoms%params dictionary</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_pbc" title="quippy.atoms.Atoms.set_pbc"><tt class="xref py py-obj docutils literal"><span class="pre">set_pbc</span></tt></a>(pbc)</td>
<td>Set periodic boundary condition flags.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_positions" title="quippy.atoms.Atoms.set_positions"><tt class="xref py py-obj docutils literal"><span class="pre">set_positions</span></tt></a>(newpositions)</td>
<td>Set positions, honoring any constraints.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_scaled_positions" title="quippy.atoms.Atoms.set_scaled_positions"><tt class="xref py py-obj docutils literal"><span class="pre">set_scaled_positions</span></tt></a>(scaled)</td>
<td>Set positions relative to unit cell.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_tags" title="quippy.atoms.Atoms.set_tags"><tt class="xref py py-obj docutils literal"><span class="pre">set_tags</span></tt></a>(tags)</td>
<td>Set tags for all atoms.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_velocities" title="quippy.atoms.Atoms.set_velocities"><tt class="xref py py-obj docutils literal"><span class="pre">set_velocities</span></tt></a>(velocities)</td>
<td>Set the momenta by specifying the velocities.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.set_zs" title="quippy.atoms.Atoms.set_zs"><tt class="xref py py-obj docutils literal"><span class="pre">set_zs</span></tt></a>([error])</td>
<td>set Zs from species</td>
</tr>
<tr class="row-even"><td><tt class="xref py py-obj docutils literal"><span class="pre">shallow_copy</span></tt>()</td>
<td>Return a shallow copy of <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><tt class="xref py py-obj docutils literal"><span class="pre">shallow_copy_from</span></tt>(other)</td>
<td>Transform <cite>self</cite> into a shallow copy of <cite>other</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.shuffle" title="quippy.atoms.Atoms.shuffle"><tt class="xref py py-obj docutils literal"><span class="pre">shuffle</span></tt></a>(new_indices,[error])</td>
<td>Reshuffle the order of the atomic indices to new_indices.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.sort" title="quippy.atoms.Atoms.sort"><tt class="xref py py-obj docutils literal"><span class="pre">sort</span></tt></a>(sort_index,[error])</td>
<td>sort atoms according to an externally provided field</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.sort_by_rindex" title="quippy.atoms.Atoms.sort_by_rindex"><tt class="xref py py-obj docutils literal"><span class="pre">sort_by_rindex</span></tt></a>(sort_index,[error])</td>
<td>sort atoms according to an externally provided field</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.transform_basis" title="quippy.atoms.Atoms.transform_basis"><tt class="xref py py-obj docutils literal"><span class="pre">transform_basis</span></tt></a>(l,[rank1,rank2,error])</td>
<td>Basis transformation of rank 0, 1 and 2 tensors real values in Atoms object.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.translate" title="quippy.atoms.Atoms.translate"><tt class="xref py py-obj docutils literal"><span class="pre">translate</span></tt></a>(displacement)</td>
<td>Translate atomic positions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.undo_com_motion" title="quippy.atoms.Atoms.undo_com_motion"><tt class="xref py py-obj docutils literal"><span class="pre">undo_com_motion</span></tt></a>(at,[persistent])</td>
<td>undo center of mass motion, with or without persistent atoms object</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.undo_pbc_jumps" title="quippy.atoms.Atoms.undo_pbc_jumps"><tt class="xref py py-obj docutils literal"><span class="pre">undo_pbc_jumps</span></tt></a>(at,[persistent])</td>
<td>undo pbc jumps, assuming nearest periodic image, with or without persistent atoms object</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.unskew_cell" title="quippy.atoms.Atoms.unskew_cell"><tt class="xref py py-obj docutils literal"><span class="pre">unskew_cell</span></tt></a>([error])</td>
<td>Unskew lattice so the cosines of the lattice angles fall between</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.write" title="quippy.atoms.Atoms.write"><tt class="xref py py-obj docutils literal"><span class="pre">write</span></tt></a>([dest,&nbsp;format,&nbsp;properties,&nbsp;prefix])</td>
<td>Write this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object to <cite>dest</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.write_cinoutput" title="quippy.atoms.Atoms.write_cinoutput"><tt class="xref py py-obj docutils literal"><span class="pre">write_cinoutput</span></tt></a>(...)</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.z_index_to_index" title="quippy.atoms.Atoms.z_index_to_index"><tt class="xref py py-obj docutils literal"><span class="pre">z_index_to_index</span></tt></a>(z,z_index,[error])</td>
<td>Inverse of atoms_index_to_z_index</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#quippy.atoms.Atoms.zero" title="quippy.atoms.Atoms.zero"><tt class="xref py py-obj docutils literal"><span class="pre">zero</span></tt></a>([indices])</td>
<td>Zero data in an Atoms structure &#8212; this doesn``t finalise it or change it``s size.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#quippy.atoms.Atoms.zero_angular_momentum" title="quippy.atoms.Atoms.zero_angular_momentum"><tt class="xref py py-obj docutils literal"><span class="pre">zero_angular_momentum</span></tt></a>(*args,&nbsp;**kwargs)</td>
<td>give the system a rigid body rotation so as to zero the angular momentum about the centre of mass</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="quippy.atoms.Atoms.add_atoms">
<tt class="descname">add_atoms</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.add_atoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add one or more atoms to an Atoms object.
To add a single atom, &#8216;pos&#8217; should be an array of size 3 and &#8216;z a
single integer. To add multiple atoms either arrays of length
&#8216;n_new&#8217; should be passed, or another Atoms from which to copy data
should be given as the &#8216;from&#8217; argument.</p>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">add_atoms</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">add_atoms</tt><big>(</big><em>pos</em>, <em>z</em><span class="optional">[</span>, <em>mass</em>, <em>travel</em>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>z</strong> (<em>input int</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input float, optional</em>) &#8211; </li>
<li><strong>travel</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">add_atom_single</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_atoms</tt><big>(</big><em>from</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>from</strong> (<a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_join</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_atoms</tt><big>(</big><em>pos</em>, <em>z</em><span class="optional">[</span>, <em>mass</em>, <em>velo</em>, <em>acc</em>, <em>travel</em>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>z</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n2)</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n3), optional</em>) &#8211; </li>
<li><strong>velo</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n4,qp_n5), optional</em>) &#8211; </li>
<li><strong>acc</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n6,qp_n7), optional</em>) &#8211; </li>
<li><strong>travel</strong> (<em>input rank-2 array(&#8216;i&#8217;) with bounds (qp_n8,qp_n9), optional</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">add_atom_multiple</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_cut_hydrogens">
<tt class="descname">add_cut_hydrogens</tt><big>(</big><em>qmlist</em><span class="optional">[</span>, <em>heuristics_nneighb_only</em>, <em>verbosity</em>, <em>alt_connect</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.add_cut_hydrogens" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given an atoms structure and a list of quantum atoms, find X-H
bonds which have been cut and include the other atom of
the pair in the quantum list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>qmlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<p><strong>heuristics_nneighb_only</strong> :  input int, optional</p>
<p><strong>verbosity</strong> :  input int, optional</p>
<p class="last"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">add_cut_hydrogens</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/clusters.f95">libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_property">
<tt class="descname">add_property</tt><big>(</big><em>name</em>, <em>value</em>, <em>n_cols=None</em>, <em>overwrite=None</em>, <em>property_type=None</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.add_property"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.add_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add a new property to this Atoms object.</p>
<p><cite>name</cite> is the name of the new property and <cite>value</cite> should be
either a scalar or an array representing the value, which should
be either integer, real, logical or string.</p>
<p>If a scalar is given for <cite>value</cite> it is copied to every element
in the new property.  <cite>n_cols</cite> can be specified to create a 2D
property from a scalar initial value - the default is 1 which
creates a 1D property.</p>
<p>If an array is given for <cite>value</cite> it should either have shape
(self.n,) for a 1D property or (n_cols,self.n) for a 2D
property.  In this case <cite>n_cols</cite> is inferred from the shape of
the <cite>value</cite> and shouldn&#8217;t be passed as an argument.</p>
<p>If <cite>property_type</cite> is present, then no attempt is made to
infer the type from <cite>value</cite>. This is necessary to resolve
ambiguity between integer and logical types.</p>
<p>If property with the same type is already present then no error
occurs.If <cite>overwrite</cite> is true, the value will be overwritten with
that given in <cite>value</cite>, otherwise the old value is retained.</p>
<p>Here are some examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mf">10.0</span><span class="o">*</span><span class="n">fidentity</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;mark&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c"># Scalar integer</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>              <span class="c"># Scalar logical</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;local_energy&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>        <span class="c"># Scalar real</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;force&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_cols</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>     <span class="c"># Vector real</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>                <span class="c"># Scalar string</span>

<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;count&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>  <span class="c"># From list</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;norm_pos&#39;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">norm</span><span class="p">())</span>         <span class="c"># From 1D array</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="s">&#39;pos&#39;</span><span class="p">,</span> <span class="n">new_pos</span><span class="p">)</span>                   <span class="c"># Overwrite positions with array new_pos</span>
                                                 <span class="c"># which should have shape (3,10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.add_property_from_pointer">
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.add_property_from_pointer" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add a per-atom property to this atoms object, but point to existing space
rather than allocating new space for it (as add_property does).</p>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">add_property_from_pointer</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-3 array(&#8216;S&#8217;) with bounds (qp_n0,qp_n1,(1))</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_str</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_real</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_int</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_real_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-2 array(&#8216;i&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_int_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">add_property_from_pointer</tt><big>(</big><em>name</em>, <em>ptr</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>ptr</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_add_property_p_logical</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.angular_momentum">
<tt class="descname">angular_momentum</tt><big>(</big><span class="optional">[</span><em>origin</em>, <em>indices</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.angular_momentum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the angular momentum of all the atoms in this DynamicalSystem, defined by
<img class="math" src="_images/math/ede2d8f94fbc6c451abbbe27d607904bcef7f7c0.png" alt="\mathbf{L} = \sum_{i} \mathbf{r_i} \times \mathbf{v_i}"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_l</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_angular_momentum</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.append">
<tt class="descname">append</tt><big>(</big><em>atom</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.append" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Append atom to end.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.assignment">
<tt class="descname">assignment</tt><big>(</big><em>to</em>, <em>from</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.assignment" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Overloaded assigment operators for Atoms objects.
Overloaded assigment operators for Connection objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>to</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p class="last"><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">assignment</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_grow_list">
<tt class="descname">bfs_grow_list</tt><big>(</big><em>list</em>, <em>n</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>alt_connect</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.bfs_grow_list" title="Permalink to this definition">Â¶</a></dt>
<dd><p>On exit, <tt class="docutils literal"><span class="pre">list</span></tt> will have been grown by <tt class="docutils literal"><span class="pre">n</span></tt> bond hops.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<p><strong>n</strong> :  input int</p>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<p><strong>min_images_only</strong> :  input int, optional</p>
<p class="last"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">bfs_grow_list</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/clusters.f95">libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_grow_single">
<tt class="descname">bfs_grow_single</tt><big>(</big><em>atom</em>, <em>n</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>alt_connect</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.bfs_grow_single" title="Permalink to this definition">Â¶</a></dt>
<dd><p>On exit, <tt class="docutils literal"><span class="pre">list</span></tt> will contain <tt class="docutils literal"><span class="pre">atom</span></tt> (with shift <tt class="docutils literal"><span class="pre">000</span></tt>)
plus the atoms within <tt class="docutils literal"><span class="pre">n</span></tt> bonds hops of it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>atom</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<p><strong>min_images_only</strong> :  input int, optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">bfs_grow_single</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/clusters.f95">libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.bfs_step">
<tt class="descname">bfs_step</tt><big>(</big><em>input</em><span class="optional">[</span>, <em>nneighb_only</em>, <em>min_images_only</em>, <em>max_r</em>, <em>alt_connect</em>, <em>property</em>, <em>debugfile</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.bfs_step" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Execute one Breadth-First-Search move on the atomic connectivity graph.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>input</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<blockquote>
<div><p>Table with intsize 4. First integer column is indices of atoms
already in the region, next 3 are shifts.</p>
</div></blockquote>
<p><strong>nneighb_only</strong> :  input int, optional</p>
<blockquote>
<div><p>If present and true, sets whether only neighbours
within the sum of the two respective covalent radii (multiplied by the atom&#8217;s nneightol) are included,
irrespective of the cutoff in the atoms structure
(default is true).</p>
</div></blockquote>
<p><strong>min_images_only</strong> :  input int, optional</p>
<blockquote>
<div><p>If true, there will be no repeated atomic indices in final list - only the
minimum shift image of those found will be included. Default is false.</p>
</div></blockquote>
<p><strong>max_r</strong> :  input float, optional</p>
<blockquote>
<div><p>if present, only neighbors within this range will be included</p>
</div></blockquote>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>property</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>debugfile</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><tt class="xref py py-class docutils literal"><span class="pre">InOutput</span></tt></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>output</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<blockquote class="last">
<div><p>Table with intsize 4, containing the new atomic
indices and shifts.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">bfs_step</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/clusters.f95">libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_connect">
<tt class="descname">calc_connect</tt><big>(</big><span class="optional">[</span><em>alt_connect</em>, <em>own_neighbour</em>, <em>store_is_min_image</em>, <em>skip_zero_zero_bonds</em>, <em>store_n_neighb</em>, <em>max_pos_change</em>, <em>did_rebuild</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_connect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Fast <img class="math" src="_images/math/4d51d3f476c76dc066b26271168bc3b67f49d2be.png" alt="O(N)"/> connectivity calculation routine. It divides the unit
cell into similarly shaped subcells, of sufficient size that
sphere of radius <tt class="docutils literal"><span class="pre">cutoff</span></tt> is contained in a subcell, at least in
the directions in which the unit cell is big enough. For very
small unit cells, there is only one subcell, so the routine is
equivalent to the standard <img class="math" src="_images/math/8912be2deda42f022bc42bf2ab30cb3c7c6f5d55.png" alt="O(N^2)"/> method.&gt;
If <tt class="docutils literal"><span class="pre">own_neighbour</span></tt> is true, atoms can be neighbours with their
own periodic images.
If <tt class="docutils literal"><span class="pre">cutoff_skin</span></tt> is present, effective cutoff is increased by this
amount, and full recalculation of connectivity is only done when
any atom has moved more than 0.5*cutoff_skin - otherwise
calc_dists() is called to update the stored distance tables.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>own_neighbour</strong> :  input int, optional</p>
<p><strong>store_is_min_image</strong> :  input int, optional</p>
<p><strong>skip_zero_zero_bonds</strong> :  input int, optional</p>
<p><strong>store_n_neighb</strong> :  input int, optional</p>
<p><strong>max_pos_change</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>did_rebuild</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_connect</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_connect_hysteretic">
<tt class="descname">calc_connect_hysteretic</tt><big>(</big><span class="optional">[</span><em>alt_connect</em>, <em>origin</em>, <em>extent</em>, <em>own_neighbour</em>, <em>store_is_min_image</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_connect_hysteretic" title="Permalink to this definition">Â¶</a></dt>
<dd><p>As for <tt class="docutils literal"><span class="pre">calc_connect</span></tt>, but perform the connectivity update
hystertically: atoms must come within <tt class="docutils literal"><span class="pre">cutoff</span></tt> to be considered
neighbours, and then will remain connect until them move apart
further than <tt class="docutils literal"><span class="pre">cutoff_break</span></tt>.</p>
<p>Typically <tt class="docutils literal"><span class="pre">alt_connect</span></tt> should be set to the
<tt class="docutils literal"><span class="pre">hysteretic_connect</span></tt> attribute. <tt class="docutils literal"><span class="pre">origin</span></tt> and <tt class="docutils literal"><span class="pre">extent</span></tt>
vectors can be used to restrict the hysteretic region to only
part of the entire system &#8211; the <tt class="docutils literal"><span class="pre">estimate_origin_extent()</span></tt>
routine in clusters.f95 can be used to guess suitable values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>extent</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3), optional</p>
<p><strong>own_neighbour</strong> :  input int, optional</p>
<p><strong>store_is_min_image</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_connect_hysteretic</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_dists">
<tt class="descname">calc_dists</tt><big>(</big><span class="optional">[</span><em>alt_connect</em>, <em>parallel</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_dists" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Update stored distance tables. To be called after moving atoms, in between calls to calc_connect().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>parallel</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_dists</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_msd">
<tt class="descname">calc_msd</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>mask</em>, <em>reset_msd</em>, <em>persistent</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_msd" title="Permalink to this definition">Â¶</a></dt>
<dd><p>calculate mean squared displacement, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work.
usually desirable to call undo_pbc_jumps and undo_CoM_motion first</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>reset_msd</strong> :  input int, optional</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_msd</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_qw">
<tt class="descname">calc_qw</tt><big>(</big><em>l</em><span class="optional">[</span>, <em>do_q</em>, <em>do_w</em>, <em>cutoff</em>, <em>cutoff_transition_width</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_qw" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> :  input int</p>
<p><strong>do_q</strong> :  input int, optional</p>
<p><strong>do_w</strong> :  input int, optional</p>
<p><strong>cutoff</strong> :  input float, optional</p>
<p class="last"><strong>cutoff_transition_width</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_qw</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/steinhardt_nelson_qw.f95">libAtoms/steinhardt_nelson_qw.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.calc_qw_grad">
<tt class="descname">calc_qw_grad</tt><big>(</big><em>grad_ind</em>, <em>l</em><span class="optional">[</span>, <em>do_q</em>, <em>do_w</em>, <em>cutoff</em>, <em>cutoff_transition_width</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.calc_qw_grad" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>grad_ind</strong> :  input int</p>
<p><strong>l</strong> :  input int</p>
<p><strong>do_q</strong> :  input int, optional</p>
<p><strong>do_w</strong> :  input int, optional</p>
<p><strong>cutoff</strong> :  input float, optional</p>
<p class="last"><strong>cutoff_transition_width</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">calc_qw_grad</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/steinhardt_nelson_qw.f95">libAtoms/steinhardt_nelson_qw.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cell_volume">
<tt class="descname">cell_volume</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.cell_volume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>atoms_cell_volume</p>
<p>calculate volume of unit cell
Returns the (unsigned) volume of the simulation cell of this Atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_atoms_cell_volume</strong> :  float</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cell_volume</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.center">
<tt class="descname">center</tt><big>(</big><em>vacuum=None</em>, <em>axis=(0</em>, <em>1</em>, <em>2)</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.center" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Center atoms in unit cell.</p>
<p>Centers the atoms in the unit cell, so there is the same
amount of vacuum on all sides.</p>
<dl class="docutils">
<dt>vacuum: float (default: None)</dt>
<dd>If specified adjust the amount of vacuum when centering.
If vacuum=10.0 there will thus be 10 Angstrom of vacuum
on each side.</dd>
<dt>axis: int or sequence of ints</dt>
<dd>Axis or axes to act on.  Default: Act on all axes.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.centre_of_mass">
<tt class="descname">centre_of_mass</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>index_list</em>, <em>mask</em>, <em>origin</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.centre_of_mass" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the centre of mass of an atoms object, using the closest images to the origin atom,
or first atom if this is not specified.  If origin is zero, use actual position, not minimum image.
If an <tt class="docutils literal"><span class="pre">index_list</span></tt> is present, just calculate it for that subset of atoms (then the origin atom is
the first in this list unless it is specified separately).</p>
<p>Note: Because the origin can be specified separately it need not be one of the atoms in the
calculation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <tt class="xref py py-class docutils literal"><span class="pre">atoms</span></tt> object</p>
<p><strong>index_list</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n1), optional</p>
<p><strong>origin</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_com</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">centre_of_mass</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.closest_atom">
<tt class="descname">closest_atom</tt><big>(</big><em>r</em>, <em>cell_image_na</em>, <em>cell_image_nb</em>, <em>cell_image_nc</em><span class="optional">[</span>, <em>mask</em>, <em>dist</em>, <em>diff</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.closest_atom" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>r</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>cell_image_na</strong> :  input int</p>
<p><strong>cell_image_nb</strong> :  input int</p>
<p><strong>cell_image_nc</strong> :  input int</p>
<p><strong>mask</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</p>
<p><strong>dist</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>diff</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_closest_atom</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">closest_atom</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.coalesce_in_one_periodic_image">
<tt class="descname">coalesce_in_one_periodic_image</tt><big>(</big><span class="optional">[</span><em>seed</em>, <em>is_periodic</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.coalesce_in_one_periodic_image" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>move atoms around following neighbor list bonds so that all are in the same periodic image</dt>
<dd>(that of <tt class="docutils literal"><span class="pre">seed</span></tt>, if present)</dd>
</dl>
<p>poorly tested, especially for situations where not all atoms are in one connected clump
probably needs a better subroutine name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>seed</strong> :  input int, optional</p>
<p><strong>is_periodic</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">coalesce_in_one_periodic_image</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.complement">
<tt class="descname">complement</tt><big>(</big><em>at</em>, <em>inlist</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.complement" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the complement of a list, i.e. all those atoms not included
in list. Result is in outlist on exit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>inlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>outlist</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">complement</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.copy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a copy of this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_entry">
<tt class="descname">copy_entry</tt><big>(</big><em>src</em>, <em>dst</em><span class="optional">[</span>, <em>swap</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.copy_entry" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Copy an atom to a different index
Move a single atom from one location to another one.
The destination will be overriden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>src</strong> :  input int</p>
<p><strong>dst</strong> :  input int</p>
<p><strong>swap</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">copy_entry</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_from">
<tt class="descname">copy_from</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.copy_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.copy_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Replace contents of this Atoms object with data from <cite>other</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_properties">
<tt class="descname">copy_properties</tt><big>(</big><em>from</em>, <em>property_list</em><span class="optional">[</span>, <em>case_sensitive</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.copy_properties" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Copy some properties from one atoms struct to another
The destination will be overriden.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>property_list</strong> :  input string(len=-1)</p>
<p><strong>case_sensitive</strong> :  input int, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">copy_properties</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.copy_without_connect">
<tt class="descname">copy_without_connect</tt><big>(</big><em>to</em>, <em>from</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.copy_without_connect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Make a copy of the atoms object <tt class="docutils literal"><span class="pre">from</span></tt> without including
connectivity information. Useful for saving the state of a
dynamical simulation without incurring too great a memory
cost.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>to</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>from</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_copy_without_connect</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cosine">
<tt class="descname">cosine</tt><big>(</big><em>i</em>, <em>j</em>, <em>k</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.cosine" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Cosine of the angle j&#8211;i&#8211;k</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>k</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_cosine</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cosine</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cosine_neighbour">
<tt class="descname">cosine_neighbour</tt><big>(</big><em>i</em>, <em>n</em>, <em>m</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.cosine_neighbour" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Cosine of the angle n&#8211;i&#8211;m where {<img class="math" src="_images/math/64b057f2648659ddd229341cecdae58d08751849.png" alt="n,m"/>} are the {:math:<a href="#id9"><span class="problematic" id="id10">`</span></a>n`th, :math:<a href="#id11"><span class="problematic" id="id12">`</span></a>m`th} neighbours of i</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>m</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_cosine_neighbour</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cosine_neighbour</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cutoff_">
<tt class="descname">cutoff_</tt><big>(</big><em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.cutoff_" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return cutoff used for bonds of type Z1&#8211;Z2
Return the actual cutoff in AA{} used by this atoms object
used to form <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bonds. If <tt class="docutils literal"><span class="pre">this.use_uniform_cutoff</span></tt> is
true, then this is simply <tt class="docutils literal"><span class="pre">this.cutoff</span></tt>, otherwise the
cutoff is used multiplied by the <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bond-length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_atoms_cutoff</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cutoff</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.cutoff_break_">
<tt class="descname">cutoff_break_</tt><big>(</big><em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.cutoff_break_" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return cutoff_break used for bonds of type Z1&#8211;Z2
Return the actual cutoff in AA{} used by this atoms object
used to break <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bonds. If <tt class="docutils literal"><span class="pre">this.use_uniform_cutoff</span></tt> is
true, then this is simply <tt class="docutils literal"><span class="pre">this.cutoff</span></tt>, otherwise the
cutoff is used multiplied by the <tt class="docutils literal"><span class="pre">Z1---Z2</span></tt> bond-length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_atoms_cutoff_break</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">cutoff_break</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.density">
<tt class="descname">density</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.density"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.density" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Density in units of <img class="math" src="_images/math/846ffd8410b4e884443d8b7f2df37cc417186f4c.png" alt="g/m^3"/>. If <cite>mass</cite> property exists,
use that, otherwise we use <cite>z</cite> and ElementMass table.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.diff">
<tt class="descname">diff</tt><big>(</big><em>i</em>, <em>j</em>, <em>shift</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.diff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Difference vector between atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> if they are separated by a shift of <tt class="docutils literal"><span class="pre">shift</span></tt></p>
<div class="math">
<p><img src="_images/math/3edb8d8b8a6d26fb6ad4223b6219a27cc4cadc67.png" alt="\mathbf{u}_{ij} = \mathbf{r}_j - \mathbf{r}_i + \mathbf{R} \cdot  \mathbf{s}"/></p>
</div><p>where <img class="math" src="_images/math/ff6cfab7c0ba183019cdbbfcb00f139e8044cf95.png" alt="\mathbf{R}"/> is the <tt class="docutils literal"><span class="pre">lattice</span></tt> matrix and <img class="math" src="_images/math/b65434e0533eb4c0ecf4469a1d8a9fb197260cc9.png" alt="\mathbf{s}"/> the shift</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">diff</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.diff_min_image">
<tt class="descname">diff_min_image</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.diff_min_image" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>Return the minimum image difference vector between two atoms or</dt>
<dd>positions. End points can be specified by any combination of
atoms indices &#8216;i&#8217; and &#8216;j&#8217; and absolute coordinates &#8216;u&#8217; and
&#8216;w&#8217;.</dd>
</dl>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">diff_min_image</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">diff_min_image</tt><big>(</big><em>v</em>, <em>j</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_vec_atom</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">diff_vec_atom</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">diff_min_image</tt><big>(</big><em>i</em>, <em>w</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_atom_vec</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">diff_atom_vec</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">diff_min_image</tt><big>(</big><em>i</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_atom_atom</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">diff_atom_atom</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">diff_min_image</tt><big>(</big><em>v</em>, <em>w</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_diff_vec_vec</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">diff_vec_vec</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.direction_cosines">
<tt class="descname">direction_cosines</tt><big>(</big><em>i</em>, <em>j</em>, <em>shift</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.direction_cosines" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given two atoms <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> and a shift returns the direction
cosines of the differnece vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_direction_cosines</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">direction_cosines</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.direction_cosines_min_image">
<tt class="descname">direction_cosines_min_image</tt><big>(</big><em>i</em>, <em>j</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.direction_cosines_min_image" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Direction cosines of the difference vector from <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> to <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_direction_cosines_min_image</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">direction_cosines_min_image</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.directionality">
<tt class="descname">directionality</tt><big>(</big><em>origin</em>, <em>list</em><span class="optional">[</span>, <em>method</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.directionality" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given an origin atom and a list of other atoms, give information as to whether the other atoms
are distributed roughly linearly, planar or spherically around the origin atom.</p>
<p>The most notable use is to check that the splines in adjustable potential will be able to reproduce
a randomly oriented force difference well.</p>
<p>The information returned is the set of eigenvectors and associated eigenvalues of the directionality
ellipsoid. One large e-value suggests roughly linear clustering, two similar and one small e-values suggest
a planar distribution, while three similar e-values suggests almost spherical distribution (when copies of
the atoms reflected through the origin atom are also considered).</p>
<p>To acheive a more spherical distribution, atoms along the e-vector(s) with the smallest e-value(s) should be
added to the index list (See <tt class="docutils literal"><span class="pre">CosAngle_To_Line</span></tt> below).</p>
<p>The matrix which is diagonalised is an average of the outer products of the unit vectors from the origin
atom to the other atoms.</p>
<p>An outer product has 1 eigenvector which is the vector it was constructed from with
eigenvalue 1 and the other eigenvectors have eigenvalue 0.</p>
<p>The eigenvalues of the averaged matrix sum to 1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>origin</strong> :  input int</p>
<blockquote>
<div><p>The origin atom</p>
</div></blockquote>
<p><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<blockquote>
<div><p>Indices and shifts of the other atoms relative to origin</p>
</div></blockquote>
<p><strong>evalues</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<blockquote>
<div><p>Eigenvalues of the directionality matrix</p>
</div></blockquote>
<p><strong>evectors</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<blockquote>
<div><p>Eigenvectors of the directionality matrix</p>
</div></blockquote>
<p><strong>method</strong> :  input int, optional</p>
<blockquote>
<div><p><tt class="docutils literal"><span class="pre">METHOD</span> <span class="pre">=</span> <span class="pre">1</span></tt> Directionality ellipsoid method.
<tt class="docutils literal"><span class="pre">METHOD</span> <span class="pre">=</span> <span class="pre">2</span></tt> Singular Value Decomposition method (default)</p>
</div></blockquote>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">directionality</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.distance">
<tt class="descname">distance</tt><big>(</big><em>i</em>, <em>j</em>, <em>shift</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.distance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return distance between atoms <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> if they are separated by a shift
of <tt class="docutils literal"><span class="pre">shift</span></tt>.</p>
<div class="math">
<p><img src="_images/math/9c6d629b14fbee517ed725d05005de4aaa342249.png" alt="r_{ij} = \left| \mathbf{r}_j - \mathbf{r}_i + \mathbf{R} \cdot  \mathbf{s} \right|"/></p>
</div><p>where <img class="math" src="_images/math/ff6cfab7c0ba183019cdbbfcb00f139e8044cf95.png" alt="\mathbf{R}"/> is the <tt class="docutils literal"><span class="pre">lattice</span></tt> matrix and <img class="math" src="_images/math/b65434e0533eb4c0ecf4469a1d8a9fb197260cc9.png" alt="\mathbf{s}"/> the shift.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>shift</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (3)</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">distance</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.distance_min_image">
<tt class="descname">distance_min_image</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.distance_min_image" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>This interface calculates the distance between the nearest periodic images of two points (or atoms).</dt>
<dd>Return minimum image distance between two atoms or positions.
End points can be specified by any combination of atoms indices
&#8216;i&#8217; and &#8216;j&#8217; and absolute coordinates &#8216;u&#8217; and &#8216;w&#8217;. If &#8216;shift&#8217; is
present the periodic shift between the two atoms or points will
be returned in it.</dd>
</dl>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">distance_min_image</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">distance_min_image</tt><big>(</big><em>v</em>, <em>w</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>w</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_vec_vec</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">distance8_vec_vec</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">distance_min_image</tt><big>(</big><em>i</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_atom_atom</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">distance8_atom_atom</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">distance_min_image</tt><big>(</big><em>i</em>, <em>v</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_atom_vec</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">distance8_atom_vec</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">distance_min_image</tt><big>(</big><em>v</em>, <em>j</em><span class="optional">[</span>, <em>shift</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>v</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>j</strong> (<em>input int</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_distance8_vec_atom</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">distance8_vec_atom</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.edit">
<tt class="descname">edit</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.edit" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Modify atoms interactively through ase-gui viewer.</p>
<p>Conflicts leading to undesirable behaviour might arise
when matplotlib has been pre-imported with certain
incompatible backends and while trying to use the
plot feature inside the interactive ag. To circumvent,
please set matplotlib.use(&#8216;gtk&#8217;) before calling this
method.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.equivalent">
<tt class="descname">equivalent</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.equivalent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.equivalent" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test for equivalence of two Atoms objects.</p>
<p>Equivalence is less strong than equality.  Equality (written
<cite>self == other</cite>) requires all properties and parameters to be
equal. Equivalence requires only that the number of atoms,
positions, atomic numbers, unit cell and periodic boundary
conditions match.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The quippy expression a.equivalent(b) has the same
definition as a == b in ASE. This means that a quippy.Atoms
instance can be compared with an ase.Atoms instance using
this method.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.extend">
<tt class="descname">extend</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.extend" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Extend atoms object by appending atoms from <em>other</em>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.fake_smooth_pos">
<tt class="descname">fake_smooth_pos</tt><big>(</big><em>at</em>, <em>mix</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.fake_smooth_pos" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p><strong>mix</strong> :  input float</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">fake_smooth_pos</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_all_distances">
<tt class="descname">get_all_distances</tt><big>(</big><em>mic=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_all_distances" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return distances of all of the atoms with all of the atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_angle">
<tt class="descname">get_angle</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_angle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get angle formed by three atoms.</p>
<p>calculate angle between the vectors list[1]-&gt;list[0] and
list[1]-&gt;list[2], where list contains the atomic indexes in
question.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_angular_momentum">
<tt class="descname">get_angular_momentum</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_angular_momentum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get total angular momentum with respect to the center of mass.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_array">
<tt class="descname">get_array</tt><big>(</big><em>name</em>, <em>copy=True</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get an array.</p>
<p>Returns a copy unless the optional argument copy is false.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_atom">
<tt class="descname">get_atom</tt><big>(</big><em>i</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.get_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.get_atom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a dictionary containing the properties of the atom with
index <cite>i</cite>. If fortran_indexing=True (the default), <cite>i</cite> should be in
range 1..self.n, otherwise it should be in range 0..(self.n-1).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_atomic_numbers">
<tt class="descname">get_atomic_numbers</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_atomic_numbers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get integer array of atomic numbers.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_calculation_done">
<tt class="descname">get_calculation_done</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_calculation_done" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Let the calculator calculate its thing,
using the current input.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_calculator">
<tt class="descname">get_calculator</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_calculator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get currently attached calculator object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_cell">
<tt class="descname">get_cell</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the three unit cell vectors as a 3x3 ndarray.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_celldisp">
<tt class="descname">get_celldisp</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_celldisp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the unit cell displacement vectors.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_center_of_mass">
<tt class="descname">get_center_of_mass</tt><big>(</big><em>scaled=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_center_of_mass" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the center of mass.</p>
<p>If scaled=True the center of mass in scaled coordinates
is returned.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_charges">
<tt class="descname">get_charges</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_charges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get calculated charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_chemical_formula">
<tt class="descname">get_chemical_formula</tt><big>(</big><em>mode='hill'</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_chemical_formula" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the chemial formula as a string based on the chemical symbols.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>mode: str</dt>
<dd><p class="first">There are three different modes available:</p>
<p>&#8216;all&#8217;: The list of chemical symbols are contracted to at string,
e.g. [&#8216;C&#8217;, &#8216;H&#8217;, &#8216;H&#8217;, &#8216;H&#8217;, &#8216;O&#8217;, &#8216;H&#8217;] becomes &#8216;CHHHOH&#8217;.</p>
<p>&#8216;reduce&#8217;: The same as &#8216;all&#8217; where repeated elements are contracted
to a single symbol and a number, e.g. &#8216;CHHHOCHHH&#8217; is reduced to
&#8216;CH3OCH3&#8217;.</p>
<p class="last">&#8216;hill&#8217;: The list of chemical symbols are contracted to a string
following the Hill notation (alphabetical order with C and H
first), e.g. &#8216;CHHHOCHHH&#8217; is reduced to &#8216;C2H6O&#8217; and &#8216;SOOHOHO&#8217; to
&#8216;H2O4S&#8217;. This is default.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_chemical_symbols">
<tt class="descname">get_chemical_symbols</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_chemical_symbols" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get list of chemical symbol strings.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_dihedral">
<tt class="descname">get_dihedral</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_dihedral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate dihedral angle.</p>
<p>Calculate dihedral angle between the vectors list[0]-&gt;list[1]
and list[2]-&gt;list[3], where list contains the atomic indexes
in question.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_dipole_moment">
<tt class="descname">get_dipole_moment</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_dipole_moment" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the electric dipole moment for the atoms object.</p>
<p>Only available for calculators which has a get_dipole_moment()
method.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_distance">
<tt class="descname">get_distance</tt><big>(</big><em>a0</em>, <em>a1</em>, <em>mic=False</em>, <em>vector=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_distance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return distance between two atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a0 to a1).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_distances">
<tt class="descname">get_distances</tt><big>(</big><em>a</em>, <em>indices</em>, <em>mic=False</em>, <em>vector=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_distances" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return distances of atom No.i with a list of atoms.</p>
<p>Use mic=True to use the Minimum Image Convention.
vector=True gives the distance vector (from a to self[indices]).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_forces">
<tt class="descname">get_forces</tt><big>(</big><em>apply_constraint=True</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_forces" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate atomic forces.</p>
<p>Ask the attached calculator to calculate the forces and apply
constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_initial_charges">
<tt class="descname">get_initial_charges</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_initial_charges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of initial charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_initial_magnetic_moments">
<tt class="descname">get_initial_magnetic_moments</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_initial_magnetic_moments" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of initial magnetic moments.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_kinetic_energy">
<tt class="descname">get_kinetic_energy</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_kinetic_energy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the kinetic energy.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_magnetic_moment">
<tt class="descname">get_magnetic_moment</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_magnetic_moment" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get calculated total magnetic moment.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_magnetic_moments">
<tt class="descname">get_magnetic_moments</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_magnetic_moments" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get calculated local magnetic moments.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_masses">
<tt class="descname">get_masses</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_masses" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of masses.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_momenta">
<tt class="descname">get_momenta</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_momenta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of momenta.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_moments_of_inertia">
<tt class="descname">get_moments_of_inertia</tt><big>(</big><em>vectors=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_moments_of_inertia" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the moments of inertia along the principal axes.</p>
<p>The three principal moments of inertia are computed from the
eigenvalues of the symmetric inertial tensor. Periodic boundary
conditions are ignored. Units of the moments of inertia are
amu*angstrom**2.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_number_of_atoms">
<tt class="descname">get_number_of_atoms</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_number_of_atoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the number of atoms.</p>
<p>Equivalent to len(atoms) in the standard ASE Atoms class.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_param_value">
<tt class="descname">get_param_value</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_param_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>get a (per-configuration) value from the atoms%params dictionary</p>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">get_param_value</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  float</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_real</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  string(len=10240)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_str</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em>, <em>n0</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_real_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  int</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_int</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  int</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_logical</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em>, <em>n0</em>, <em>n1</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>n1</strong> (<em>input int</em>) &#8211; shape(qp_value,1)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_real_a2</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em>, <em>value</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<tt class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></tt> object) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_es</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">get_param_value</tt><big>(</big><em>key</em>, <em>n0</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>n0</strong> (<em>input int</em>) &#8211; shape(qp_value,0)</li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>value</strong> &#8211;  rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</p>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_get_param_value_int_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_pbc">
<tt class="descname">get_pbc</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_pbc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get periodic boundary condition flags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_positions">
<tt class="descname">get_positions</tt><big>(</big><em>wrap=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_positions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of positions. If wrap==True, wraps atoms back
into unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_potential_energies">
<tt class="descname">get_potential_energies</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_potential_energies" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the potential energies of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies
(e.g. classical potentials).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_potential_energy">
<tt class="descname">get_potential_energy</tt><big>(</big><em>force_consistent=False</em>, <em>apply_constraint=True</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_potential_energy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate potential energy.</p>
<p>Ask the attached calculator to calculate the potential energy and
apply constraints.  Use <em>apply_constraint=False</em> to get the raw
forces.</p>
<p>When supported by the calculator, either the energy extrapolated
to zero Kelvin or the energy consistent with the forces (the free
energy) can be returned.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_reciprocal_cell">
<tt class="descname">get_reciprocal_cell</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_reciprocal_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the three reciprocal lattice vectors as a 3x3 ndarray.</p>
<p>Note that the commonly used factor of 2 pi for Fourier
transforms is not included here.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_scaled_positions">
<tt class="descname">get_scaled_positions</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_scaled_positions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get positions relative to unit cell.</p>
<p>Atoms outside the unit cell will be wrapped into the cell in
those directions with periodic boundary conditions so that the
scaled coordinates are between zero and one.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_stress">
<tt class="descname">get_stress</tt><big>(</big><em>voigt=True</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_stress" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate stress tensor.</p>
<p>Returns an array of the six independent components of the
symmetric stress tensor, in the traditional Voigt order
(xx, yy, zz, yz, xz, xy) or as a 3x3 matrix.  Default is Voigt
order.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_stresses">
<tt class="descname">get_stresses</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_stresses" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculate the stress-tensor of all the atoms.</p>
<p>Only available with calculators supporting per-atom energies and
stresses (e.g. classical potentials).  Even for such calculators
there is a certain arbitrariness in defining per-atom stresses.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_tags">
<tt class="descname">get_tags</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_tags" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get integer array of tags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_temperature">
<tt class="descname">get_temperature</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_temperature" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the temperature in Kelvin.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_total_energy">
<tt class="descname">get_total_energy</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_total_energy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get the total energy - potential plus kinetic energy.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_velocities">
<tt class="descname">get_velocities</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_velocities" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get array of velocities.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.get_volume">
<tt class="descname">get_volume</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.get_volume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Get volume of unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.has">
<tt class="descname">has</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.has" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Check for existence of array.</p>
<p>name must be one of: &#8216;tags&#8217;, &#8216;momenta&#8217;, &#8216;masses&#8217;, &#8216;magmoms&#8217;,
&#8216;charges&#8217;.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.has_property">
<tt class="descname">has_property</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.has_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convenience function to test if a property is present. No checking
of property type is done. Property names are case-insensitive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> :  input string(len=-1)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_atoms_has_property</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">has_property</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.index_to_z_index">
<tt class="descname">index_to_z_index</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.index_to_z_index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert from a single index in range 1..this.N to a CASTEP-style (element, index) pair</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>index</strong> :  input int</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_z_index</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">index_to_z_index</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_domain_decomposed">
<tt class="descname">is_domain_decomposed</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.is_domain_decomposed" title="Permalink to this definition">Â¶</a></dt>
<dd><p>atoms_is_domain_decomposed</p>
<p>Is this atoms object domain decomposed?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">is_domain_decomposed</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_initialised">
<tt class="descname">is_initialised</tt><big>(</big><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.is_initialised" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Is this atoms object initialised?</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ret_</strong> :  int</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">is_initialised</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_min_image">
<tt class="descname">is_min_image</tt><big>(</big><em>i</em><span class="optional">[</span>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.is_min_image" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_min_image</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">is_min_image</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_nearest_neighbour">
<tt class="descname">is_nearest_neighbour</tt><big>(</big><em>i</em>, <em>n</em><span class="optional">[</span>, <em>alt_connect</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.is_nearest_neighbour" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test if an atom&#8217;s :math:<a href="#id13"><span class="problematic" id="id14">`</span></a>n`th neighbour is one if its nearest neighbours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_nearest_neighbour</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">is_nearest_neighbour</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.is_nearest_neighbour_abs_index">
<tt class="descname">is_nearest_neighbour_abs_index</tt><big>(</big><em>i</em>, <em>j</em><span class="optional">[</span>, <em>alt_connect</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.is_nearest_neighbour_abs_index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test if an atom <tt class="docutils literal"><span class="pre">j</span></tt> is one of <a href="#id15"><span class="problematic" id="id16">``</span></a>i``s nearest neighbours</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>j</strong> :  input int</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_is_nearest_neighbour_abs_index</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">is_nearest_neighbour_abs_index</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.iteratoms">
<tt class="descname">iteratoms</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.iteratoms"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.iteratoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Iterate over atoms, calling get_atom() for each one</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.kinetic_energy">
<tt class="descname">kinetic_energy</tt><big>(</big><span class="optional">[</span><em>mpi_obj</em>, <em>local_ke</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.kinetic_energy" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the total kinetic energy <img class="math" src="_images/math/e74031185d07cfd0bd1566be386399a316a9e624.png" alt="E_k = \sum_{i} \frac{1}{2} m v^2"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mpi_obj</strong> : <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">MPI_context</span></tt></a> object, optional</p>
<p><strong>local_ke</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_ke</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_kinetic_energy</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.kinetic_virial">
<tt class="descname">kinetic_virial</tt><big>(</big><span class="optional">[</span><em>mpi_obj</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.kinetic_virial" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the total kinetic virial <img class="math" src="_images/math/f394c2f44d750bbad26ca9b3257ec68688ac24d6.png" alt="w_ij = \sum_{k} \frac{1}{2} m v_i v_j"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mpi_obj</strong> : <a class="reference internal" href="mpi_context.html#quippy.mpi_context.MPI_context" title="quippy.mpi_context.MPI_context"><tt class="xref py py-class docutils literal"><span class="pre">MPI_context</span></tt></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_kv</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_kinetic_virial</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.list_matching_prop">
<tt class="descname">list_matching_prop</tt><big>(</big><em>at</em>, <em>list</em>, <em>name</em>, <em>value</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.list_matching_prop" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Find atoms which have integer property <tt class="docutils literal"><span class="pre">prop</span></tt> with value <tt class="docutils literal"><span class="pre">value</span></tt>
and return them in a table <tt class="docutils literal"><span class="pre">list</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <tt class="xref py py-class docutils literal"><span class="pre">atoms</span></tt> object</p>
<p><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
<p><strong>name</strong> :  input string(len=-1)</p>
<p><strong>value</strong> :  input int</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">list_matching_prop</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.make_convex">
<tt class="descname">make_convex</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.make_convex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Add atoms to <tt class="docutils literal"><span class="pre">list</span></tt> to make the selection region convex, i.e. if <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and
<img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> are nearest neighbours, with <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> in the list and not <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> then <img class="math" src="_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> will be added
if more than half its nearest neighbours are in the list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">make_convex</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/clusters.f95">libAtoms/clusters.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.map_into_cell">
<tt class="descname">map_into_cell</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.map_into_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>atoms_map_into_cell</p>
<dl class="docutils">
<dt>Map atomic positions into the unit cell so that lattice</dt>
<dd>coordinates satisfy <img class="math" src="_images/math/a0718313c2bc1fb125299359718cd9569655679b.png" alt="-0.5 \le t_x,t_y,t_z &lt; 0.5"/></dd>
</dl>
<p>Map atomic fractional positions back into the unit cell
<img class="math" src="_images/math/a0718313c2bc1fb125299359718cd9569655679b.png" alt="-0.5 \le t_x,t_y,t_z &lt; 0.5"/></p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">map_into_cell</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mark_cylinder">
<tt class="descname">mark_cylinder</tt><big>(</big><em>p</em>, <em>v</em>, <em>r</em><span class="optional">[</span>, <em>periodic</em>, <em>mark_name</em>, <em>mark_value</em>, <em>intersection</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.mark_cylinder" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Mark atoms in a cylinder centred on the point <cite>p</cite> with axis <cite>v</cite> and radius <cite>r</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>v</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>r</strong> :  input float</p>
<p><strong>periodic</strong> :  input int, optional</p>
<p><strong>mark_name</strong> :  input string(len=-1), optional</p>
<p><strong>mark_value</strong> :  input int, optional</p>
<p class="last"><strong>intersection</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">mark_cylinder</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/frametools.f95">libAtoms/frametools.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mark_sphere">
<tt class="descname">mark_sphere</tt><big>(</big><em>p</em>, <em>r</em><span class="optional">[</span>, <em>periodic</em>, <em>mark_name</em>, <em>mark_value</em>, <em>intersection</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.mark_sphere" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Mark atoms in a cylinder centred on the point <cite>p</cite> with radius <cite>r</cite></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>p</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>r</strong> :  input float</p>
<p><strong>periodic</strong> :  input int, optional</p>
<p><strong>mark_name</strong> :  input string(len=-1), optional</p>
<p><strong>mark_value</strong> :  input int, optional</p>
<p class="last"><strong>intersection</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">mark_sphere</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/frametools.f95">libAtoms/frametools.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.md5_hash">
<tt class="descname">md5_hash</tt><big>(</big><em>ndigits</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.md5_hash"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.md5_hash" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Hash an atoms object with a precision of ndigits decimal
digits.  Atomic numbers, lattice and fractional positions are
fed to MD5 to form the hash.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.mem_estimate">
<tt class="descname">mem_estimate</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.mem_estimate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.mem_estimate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Estimate memory usage of this Atoms object, in bytes</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.moment_of_inertia_tensor">
<tt class="descname">moment_of_inertia_tensor</tt><big>(</big><span class="optional">[</span><em>origin</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.moment_of_inertia_tensor" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>origin</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3), optional</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_moi</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">moment_of_inertia_tensor</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.momentum">
<tt class="descname">momentum</tt><big>(</big><span class="optional">[</span><em>indices</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.momentum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the total momentum <img class="math" src="_images/math/f65d5abc743368c153c92e6f5062a4127a165b1c.png" alt="\mathbf{p} = \sum_i \mathbf{m_i} \mathbf{v_i}"/>.
Optionally only include the contribution of a subset of atoms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0), optional</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_p</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_momentum</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.n_neighbours">
<tt class="descname">n_neighbours</tt><big>(</big><em>i</em><span class="optional">[</span>, <em>max_dist</em>, <em>max_factor</em>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.n_neighbours" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Neighbour list stuff
Return the number of neighbour that atom <tt class="docutils literal"><span class="pre">i</span></tt> has.  If the
optional arguments max_dist or max_factor are present then only
neighbours closer than this cutoff are included.  <tt class="docutils literal"><span class="pre">alt_connect</span></tt>
can be set to another Connection object to use alternative
connectivity information, for example <tt class="docutils literal"><span class="pre">hysteretic_connect</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>max_dist</strong> :  input float, optional</p>
<p><strong>max_factor</strong> :  input float, optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_n</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">n_neighbours</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.neighbour">
<tt class="descname">neighbour</tt><big>(</big><em>i</em>, <em>n</em><span class="optional">[</span>, <em>distance</em>, <em>diff</em>, <em>cosines</em>, <em>shift</em>, <em>index</em>, <em>max_dist</em>, <em>jn</em>, <em>alt_connect</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.neighbour" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the index of the <img class="math" src="_images/math/564e1690873cb931ec03c3bf1ebb71b1be229940.png" alt="n^{\mbox{\small{th}}}"/> neighbour of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>. Together with the
previous function, this facilites a loop over the neighbours of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/>. Optionally, we
return other geometric information, such as distance, direction cosines and difference vector,
and also a direct index into the neighbour tables. If <img class="math" src="_images/math/d01dfa7e20a8a81ee22143f4b480a9c35120c063.png" alt="i &lt;= j"/>, this is an index into <tt class="docutils literal"><span class="pre">neighbour1(i)</span></tt>;
if <img class="math" src="_images/math/a044f4112fbdd1acdc9c2b99d39fdd137cd90c17.png" alt="i &gt; j"/>, it is an index into <tt class="docutils literal"><span class="pre">neighbour1(j)</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre>do n = 1,atoms_n_neighbours(at, i)
   j = atoms_neighbour(at, i, n, distance, diff, cosines, shift, index)

   ...
end do
</pre></div>
</div>
<p>If distance <img class="math" src="_images/math/78ebd4cdaabc38007623a06192e4af8b92432fc5.png" alt="&gt;"/> max_dist, return 0, and do not waste time calculating other quantities.
<tt class="docutils literal"><span class="pre">alt_connect</span></tt> has the same meaning as <tt class="docutils literal"><span class="pre">n_neighbours</span></tt>.</p>
<p>Here&#8217;s a typical loop construct in Python. Note how <cite>r</cite> and <cite>u</cite>
are created before the loop: arguments which are both optional
and <tt class="docutils literal"><span class="pre">intent(out)</span></tt> in Fortran are converted to <tt class="docutils literal"><span class="pre">intent(in,out)</span></tt> for quippy. ::</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span> <span class="o">=</span> <span class="n">farray</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">fzeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">frange</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">frange</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">n_neighbours</span><span class="p">(</span><span class="n">i</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">at</span><span class="o">.</span><span class="n">neighbour</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">r</span><span class="p">,</span> <span class="n">diff</span><span class="o">=</span><span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>i</strong> :  input int</p>
<p><strong>n</strong> :  input int</p>
<p><strong>distance</strong> :  in/output rank-0 array(float,&#8217;d&#8217;), optional</p>
<p><strong>diff</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>cosines</strong> :  in/output rank-1 array(&#8216;d&#8217;) with bounds (3), optional</p>
<p><strong>shift</strong> :  in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</p>
<p><strong>index</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p><strong>max_dist</strong> :  input float, optional</p>
<p><strong>jn</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
<p><strong>alt_connect</strong> : <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_j</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">neighbour</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.pop">
<tt class="descname">pop</tt><big>(</big><em>i=-1</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.pop" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove and return atom at index <em>i</em> (default last).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.print_">
<tt class="descname">print_</tt><big>(</big><span class="optional">[</span><em>file</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.print_" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Print a verbose textual description of an Atoms object to the default logger or to
a specificied Inoutput object.
Print a verbose textual description of a Connection object to the default
logger or to a specificied Inoutput object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>file</strong> : <a class="reference internal" href="system.html#quippy.system.InOutput" title="quippy.system.InOutput"><tt class="xref py py-class docutils literal"><span class="pre">InOutput</span></tt></a> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">print_</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.print_atom">
<tt class="descname">print_atom</tt><big>(</big><em>i</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.print_atom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.print_atom" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Pretty-print the properties of the atom with index <cite>i</cite></p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.prop_names_string">
<tt class="descname">prop_names_string</tt><big>(</big><span class="optional">[</span><em>with_types</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.prop_names_string" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>with_types</strong> :  input int, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_prop_names_string</strong> :  string(len=10240)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">prop_names_string</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rattle">
<tt class="descname">rattle</tt><big>(</big><em>stdev=0.001</em>, <em>seed=42</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.rattle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Randomly displace atoms.</p>
<p>This method adds random displacements to the atomic positions,
taking a possible constraint into account.  The random numbers are
drawn from a normal distribution of standard deviation stdev.</p>
<p>For a parallel calculation, it is important to use the same
seed on all processors!</p>
</dd></dl>

<dl class="classmethod">
<dt id="quippy.atoms.Atoms.read">
<em class="property">classmethod </em><tt class="descname">read</tt><big>(</big><em>source</em>, <em>format=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.read" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Class method to read Atoms object from file <cite>source</cite> according to <cite>format</cite></p>
<p>If <cite>format</cite> is None, filetype is inferred from filename.
Returns a new Atoms instance; to read into an existing Atoms
object, use the read_from() method.</p>
<p>If <cite>source</cite> corresponds to a known format then it used
to construct an appropriate iterator from the <tt class="xref py py-attr docutils literal"><span class="pre">AtomsReaders</span></tt>
dictionary. See <a class="reference internal" href="io.html#fileformats"><em>Supported File Formats</em></a> for a list of supported
file formats.</p>
<p>If <cite>source</cite> corresponds to an unknown format then it is
expected to be an iterator returning <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> objects.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.read_cinoutput">
<tt class="descname">read_cinoutput</tt><big>(</big><em>cio</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>frame</em>, <em>zero</em>, <em>range</em>, <em>str</em>, <em>estr</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.read_cinoutput" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cio</strong> : <tt class="xref py py-class docutils literal"><span class="pre">CInOutput</span></tt> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p><strong>frame</strong> :  input int, optional</p>
<p><strong>zero</strong> :  input int, optional</p>
<p><strong>range</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (2), optional</p>
<p><strong>str</strong> :  input string(len=-1), optional</p>
<p><strong>estr</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></tt> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_read_cinoutput</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/CInOutput.f95">libAtoms/CInOutput.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.read_from">
<tt class="descname">read_from</tt><big>(</big><em>source</em>, <em>**readargs</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.read_from"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.read_from" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Replace contents of this Atoms object with Atoms read from <cite>source</cite></p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.realpos">
<tt class="descname">realpos</tt><big>(</big><em>i</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.realpos" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return the real position of atom <tt class="docutils literal"><span class="pre">i</span></tt>, taking into account the
stored travel across the periodic boundary conditions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>i</strong> :  input int</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_realpos</strong> :  rank-1 array(&#8216;d&#8217;) with bounds (3)</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">realpos</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.remove_atoms">
<tt class="descname">remove_atoms</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.remove_atoms" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove one or more atoms from an Atoms object.</p>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">remove_atoms</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">remove_atoms</tt><big>(</big><em>mask</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mask</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">remove_atom_multiple_mask</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">remove_atoms</tt><big>(</big><em>i</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>i</strong> (<em>input int</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">remove_atom_single</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">remove_atoms</tt><big>(</big><em>atom_indices</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>atom_indices</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>error</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">remove_atom_multiple</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.remove_property">
<tt class="descname">remove_property</tt><big>(</big><em>name</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.remove_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Remove a property from this atoms object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> :  input string(len=-1)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">remove_property</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.repeat">
<tt class="descname">repeat</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.repeat" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create new repeated atoms object.</p>
<p>The <em>rep</em> argument should be a sequence of three positive
integers like <em>(2,3,1)</em> or a single integer (<em>r</em>) equivalent
to <em>(r,r,r)</em>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.repoint">
<tt class="descname">repoint</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.repoint" title="Permalink to this definition">Â¶</a></dt>
<dd><p>OMIT</p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_repoint</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate">
<tt class="descname">rotate</tt><big>(</big><em>axis</em>, <em>angle</em><span class="optional">[</span>, <em>rank1</em>, <em>rank2</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.rotate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rotate this Atoms object, transforming all rank 1 and rank 2 tensors parameters and properties</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axis</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (3)</p>
<p><strong>angle</strong> :  input float</p>
<p><strong>rank1</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>rank2</strong> :  input string(len=-1), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">rotate</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate_dihedral">
<tt class="descname">rotate_dihedral</tt><big>(</big><em>list</em>, <em>angle</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.rotate_dihedral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rotate dihedral angle.</p>
<p>Complementing the two routines above: rotate a group by a
predefined dihedral angle, starting from its current
configuration</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.rotate_euler">
<tt class="descname">rotate_euler</tt><big>(</big><em>center=(0</em>, <em>0</em>, <em>0)</em>, <em>phi=0.0</em>, <em>theta=0.0</em>, <em>psi=0.0</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.rotate_euler" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rotate atoms via Euler angles.</p>
<p>See e.g <a class="reference external" href="http://mathworld.wolfram.com/EulerAngles.html">http://mathworld.wolfram.com/EulerAngles.html</a> for explanation.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>center :</dt>
<dd>The point to rotate about. A sequence of length 3 with the
coordinates, or &#8216;COM&#8217; to select the center of mass, &#8216;COP&#8217; to
select center of positions or &#8216;COU&#8217; to select center of cell.</dd>
<dt>phi :</dt>
<dd>The 1st rotation angle around the z axis.</dd>
<dt>theta :</dt>
<dd>Rotation around the x axis.</dd>
<dt>psi :</dt>
<dd>2nd rotation around the z axis.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.select">
<tt class="descname">select</tt><big>(</big><em>mask=None</em>, <em>list=None</em>, <em>orig_index=True</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.select"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.select" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a new <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> containing a subset of the atoms in this Atoms object</p>
<p>One of either <cite>mask</cite> or <cite>list</cite> should be present.  If <cite>mask</cite>
is given it should be a rank one array of length <cite>self.n</cite>. In
this case atoms corresponding to true values in <cite>mask</cite> will be
included in the result.  If <cite>list</cite> is present it should be an
arry of list containing atom indices to include in the result.</p>
<p>If <cite>orig_index</cite> is True (default), the new object will contain
an <tt class="docutils literal"><span class="pre">orig_index</span></tt> property mapping the indices of the new atoms
back to the original larger Atoms object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_angle">
<tt class="descname">set_angle</tt><big>(</big><em>list</em>, <em>angle</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_angle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set angle formed by three atoms.</p>
<p>Sets the angle between vectors list[1]-&gt;list[0] and
list[1]-&gt;list[2].</p>
<p>Same usage as in set_dihedral.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_array">
<tt class="descname">set_array</tt><big>(</big><em>name</em>, <em>a</em>, <em>dtype=None</em>, <em>shape=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_array" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Update array.</p>
<p>If <em>shape</em> is not <em>None</em>, the shape of <em>a</em> will be checked.
If <em>a</em> is <em>None</em>, then the array is deleted.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_atomic_numbers">
<tt class="descname">set_atomic_numbers</tt><big>(</big><em>numbers</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_atomic_numbers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set atomic numbers.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_atoms">
<tt class="descname">set_atoms</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_atoms" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>Set atomic numbers (in the &#8216;z&#8217; integer property), species names</dt>
<dd>(in &#8216;species&#8217; string property) and optionally masses (if &#8216;mass&#8217;
property exists in the Atoms object).</dd>
</dl>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">set_atoms</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">set_atoms</tt><big>(</big><em>z</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>z</strong> (<em>input int</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_atoms_singlez</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_atoms</tt><big>(</big><em>z</em><span class="optional">[</span>, <em>mass</em><span class="optional">]</span><big>)</big></dt>
<dd><p>Set atomic numbers and optionally masses (if mass property is present)
If <tt class="docutils literal"><span class="pre">mass</span></tt> is not specified then <tt class="docutils literal"><span class="pre">ElementMass(Z)</span></tt> is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>z</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
<li><strong>mass</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n1), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_atoms</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_calculator">
<tt class="descname">set_calculator</tt><big>(</big><em>calc=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_calculator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Attach calculator object.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cell">
<tt class="descname">set_cell</tt><big>(</big><em>cell</em>, <em>scale_atoms=False</em>, <em>fix=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set unit cell vectors.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>cell :</dt>
<dd>Unit cell.  A 3x3 matrix (the three unit cell vectors) or
just three numbers for an orthorhombic cell.</dd>
<dt>scale_atoms <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>Fix atomic positions or move atoms with the unit cell?
Default behavior is to <em>not</em> move the atoms (scale_atoms=False).</dd>
</dl>
<p>Examples:</p>
<p>Two equivalent ways to define an orthorhombic cell:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">)])</span>
</pre></div>
</div>
<p>FCC unit cell:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">set_cell</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_celldisp">
<tt class="descname">set_celldisp</tt><big>(</big><em>celldisp</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_celldisp" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the unit cell displacement vectors.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_chemical_symbols">
<tt class="descname">set_chemical_symbols</tt><big>(</big><em>symbols</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_chemical_symbols" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set chemical symbols.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_comm_property">
<tt class="descname">set_comm_property</tt><big>(</big><em>propname</em><span class="optional">[</span>, <em>comm_atoms</em>, <em>comm_ghosts</em>, <em>comm_reverse</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_comm_property" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set which properties to communicate when
comm_atoms:   Communicate when atom is moved to different domain.</p>
<blockquote>
<div>Forces, for example, may be excluded since they are updated
on every time step.</div></blockquote>
<dl class="docutils">
<dt>comm_ghosts:  Communicate when atom is dublicated as a ghost on a domain.</dt>
<dd>Masses, for example, might be excluded since atoms are
propagated on the domain they reside in only.</dd>
<dt>comm_reverse: Communicate back from ghost atoms to the original domain atom</dt>
<dd>and accumulate</dd>
</dl>
<p>By default, properties are not communicated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>propname</strong> :  input string(len=-1)</p>
<p><strong>comm_atoms</strong> :  input int, optional</p>
<p><strong>comm_ghosts</strong> :  input int, optional</p>
<p class="last"><strong>comm_reverse</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_comm_property</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_constraint">
<tt class="descname">set_constraint</tt><big>(</big><em>constraint=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_constraint" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Apply one or more constrains.</p>
<p>The <em>constraint</em> argument must be one constraint object or a
list of constraint objects.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cutoff">
<tt class="descname">set_cutoff</tt><big>(</big><em>cutoff</em><span class="optional">[</span>, <em>cutoff_break</em>, <em>cutoff_skin</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_cutoff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set (a uniform) cutoff
Specify a uniform neighbour cutoff throughout the system.
If zero, revert to default (uniform_cutoff=false, factor=DEFAULT_NNEIGHTOL)
Optionally set <tt class="docutils literal"><span class="pre">cutoff_break</span></tt> for <tt class="docutils literal"><span class="pre">calc_connect_hysteretic</span></tt> at the same time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cutoff</strong> :  input float</p>
<p><strong>cutoff_break</strong> :  input float, optional</p>
<p class="last"><strong>cutoff_skin</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_cutoff</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cutoff_factor">
<tt class="descname">set_cutoff_factor</tt><big>(</big><em>factor</em><span class="optional">[</span>, <em>factor_break</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_cutoff_factor" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set cutoff factor
Specify the neighbour cutoff to be a mulitple of the bond length
of the two atoms&#8217; types.
If zero, revert to default (<tt class="docutils literal"><span class="pre">DEFAULT_NNEIGHTOL</span></tt>).
Optional argument <cite>factor_break</cite> is used by <tt class="docutils literal"><span class="pre">calc_connect_hysteretic</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>factor</strong> :  input float</p>
<p class="last"><strong>factor_break</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_cutoff_factor</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_cutoff_minimum">
<tt class="descname">set_cutoff_minimum</tt><big>(</big><em>cutoff</em><span class="optional">[</span>, <em>cutoff_break</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_cutoff_minimum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>increase cutoff
Set the cutoff (uniform or factor) to at least the requested value</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cutoff</strong> :  input float</p>
<p class="last"><strong>cutoff_break</strong> :  input float, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_cutoff_minimum</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_dihedral">
<tt class="descname">set_dihedral</tt><big>(</big><em>list</em>, <em>angle</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_dihedral" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the dihedral angle between vectors list[0]-&gt;list[1] and
list[2]-&gt;list[3] by changing the atom indexed by list[3]
if mask is not None, all the atoms described in mask
(read: the entire subgroup) are moved.</p>
<p>example: the following defines a very crude
ethane-like molecule and twists one half of it by 30 degrees.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="s">&#39;HHCCHH&#39;</span><span class="p">,</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="go">                             [1, 0, 0], [2, 1, 0], [2, -1, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span><span class="o">.</span><span class="n">set_dihedral</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="mi">7</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">,</span><span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_distance">
<tt class="descname">set_distance</tt><big>(</big><em>a0</em>, <em>a1</em>, <em>distance</em>, <em>fix=0.5</em>, <em>mic=False</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_distance" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the distance between two atoms.</p>
<p>Set the distance between atoms <em>a0</em> and <em>a1</em> to <em>distance</em>.
By default, the center of the two atoms will be fixed.  Use
<em>fix=0</em> to fix the first atom, <em>fix=1</em> to fix the second
atom and <em>fix=0.5</em> (default) to fix the center of the bond.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_initial_charges">
<tt class="descname">set_initial_charges</tt><big>(</big><em>charges=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_initial_charges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the initial charges.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_initial_magnetic_moments">
<tt class="descname">set_initial_magnetic_moments</tt><big>(</big><em>magmoms=None</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_initial_magnetic_moments" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the initial magnetic moments.</p>
<p>Use either one or three numbers for every atom (collinear
or non-collinear spins).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_lattice">
<tt class="descname">set_lattice</tt><big>(</big><em>lattice</em>, <em>scale_positions=False</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.set_lattice"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.set_lattice" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Change the lattice vectors, keeping the inverse lattice vectors
up to date. Optionally map the existing atoms into the new cell
and recalculate connectivity (by default scale_positions=False).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_map_shift">
<tt class="descname">set_map_shift</tt><big>(</big><span class="optional">[</span><em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_map_shift" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_map_shift</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_masses">
<tt class="descname">set_masses</tt><big>(</big><em>masses='defaults'</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_masses" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set atomic masses.</p>
<p>The array masses should contain a list of masses.  In case
the masses argument is not given or for those elements of the
masses list that are None, standard values are set.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_momenta">
<tt class="descname">set_momenta</tt><big>(</big><em>momenta</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_momenta" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set momenta.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_param_value">
<tt class="descname">set_param_value</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_param_value" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set a (per-configuration) value from the atoms%params dictionary</p>
<p>Wrapper around Fortran interface <tt class="docutils literal"><span class="pre">set_param_value</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_int_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_real_a2</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_int</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input string(len=-1)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_str</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_real_a</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input float</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_real</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">set_param_value</tt><big>(</big><em>key</em>, <em>value</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>key</strong> (<em>input string(len=-1)</em>) &#8211; </li>
<li><strong>value</strong> (<em>input int</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_set_param_value_logical</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_pbc">
<tt class="descname">set_pbc</tt><big>(</big><em>pbc</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_pbc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set periodic boundary condition flags.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_positions">
<tt class="descname">set_positions</tt><big>(</big><em>newpositions</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_positions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set positions, honoring any constraints.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_scaled_positions">
<tt class="descname">set_scaled_positions</tt><big>(</big><em>scaled</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_scaled_positions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set positions relative to unit cell.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_tags">
<tt class="descname">set_tags</tt><big>(</big><em>tags</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_tags" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set tags for all atoms. If only one tag is supplied, it is
applied to all atoms.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_velocities">
<tt class="descname">set_velocities</tt><big>(</big><em>velocities</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_velocities" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Set the momenta by specifying the velocities.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.set_zs">
<tt class="descname">set_zs</tt><big>(</big><span class="optional">[</span><em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.set_zs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>set Zs from species</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">set_zs</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.shuffle">
<tt class="descname">shuffle</tt><big>(</big><em>new_indices</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.shuffle" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reshuffle the order of the atomic indices to new_indices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>new_indices</strong> :  input rank-1 array(&#8216;i&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">shuffle</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.sort">
<tt class="descname">sort</tt><big>(</big><em>sort_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.sort" title="Permalink to this definition">Â¶</a></dt>
<dd><p>sort atoms according to an externally provided field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sort_index</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">sort_by_rindex</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.sort_by_rindex">
<tt class="descname">sort_by_rindex</tt><big>(</big><em>sort_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.sort_by_rindex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>sort atoms according to an externally provided field</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sort_index</strong> :  input rank-1 array(&#8216;d&#8217;) with bounds (qp_n0)</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_sort_by_rindex</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.transform_basis">
<tt class="descname">transform_basis</tt><big>(</big><em>l</em><span class="optional">[</span>, <em>rank1</em>, <em>rank2</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.transform_basis" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Basis transformation of rank 0, 1 and 2 tensors real values in Atoms object.
This routine transforms rank 1 and rank 2 tensors in this.params and
this.properties. Tensors are identified by having the correct type
(real arrays) and shape (i.e. 3, (3, 3), (3, this.N) (9, this.N) for
vector paramters, tensor parameters, vector properties and tensor
properties respectively), and by having a name which is included in
the relevant list. Extra names can be added to the lists with the
rank1 and rank2 arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>l</strong> :  input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
<p><strong>rank1</strong> :  input string(len=-1), optional</p>
<p><strong>rank2</strong> :  input string(len=-1), optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">transform_basis</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.translate">
<tt class="descname">translate</tt><big>(</big><em>displacement</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.translate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Translate atomic positions.</p>
<p>The displacement argument can be a float an xyz vector or an
nx3 array (where n is the number of atoms).</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.undo_com_motion">
<tt class="descname">undo_com_motion</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.undo_com_motion" title="Permalink to this definition">Â¶</a></dt>
<dd><p>undo center of mass motion, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">undo_com_motion</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.undo_pbc_jumps">
<tt class="descname">undo_pbc_jumps</tt><big>(</big><em>at</em><span class="optional">[</span>, <em>persistent</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.undo_pbc_jumps" title="Permalink to this definition">Â¶</a></dt>
<dd><p>undo pbc jumps, assuming nearest periodic image, with or without persistent atoms object
without persistent atoms object, global storage is used, and calling on multiple trajcetories
interspersed will not work</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>at</strong> : <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object</p>
<p class="last"><strong>persistent</strong> :  input int, optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">undo_pbc_jumps</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.unskew_cell">
<tt class="descname">unskew_cell</tt><big>(</big><span class="optional">[</span><em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.unskew_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>Unskew lattice so the cosines of the lattice angles fall between</dt>
<dd><img class="math" src="_images/math/e38b5464730f744c74c919e3496d5dd484ad892d.png" alt="-0.5"/> and <img class="math" src="_images/math/a55a85777307c1a74cfb7bf8d4d833d9bbb50046.png" alt="0.5"/></dd>
</dl>
<p>Unskew lattice so the cosines of the lattice angles fall between
<img class="math" src="_images/math/e38b5464730f744c74c919e3496d5dd484ad892d.png" alt="-0.5"/> and <img class="math" src="_images/math/a55a85777307c1a74cfb7bf8d4d833d9bbb50046.png" alt="0.5"/></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">unskew_cell</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.write">
<tt class="descname">write</tt><big>(</big><em>dest=None</em>, <em>format=None</em>, <em>properties=None</em>, <em>prefix=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#Atoms.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.Atoms.write" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write this <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object to <cite>dest</cite>. If <cite>format</cite> is
absent it is inferred from the file extension or type of <cite>dest</cite>,
as described for the <a class="reference internal" href="#quippy.atoms.Atoms.read" title="quippy.atoms.Atoms.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> method.  If <cite>properties</cite> is
present, it should be a list of property names to include in the
output file, e.g. <cite>[&#8216;species&#8217;, &#8216;pos&#8217;]</cite>.</p>
<p>See <a class="reference internal" href="io.html#fileformats"><em>Supported File Formats</em></a> for a list of supported file formats.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.write_cinoutput">
<tt class="descname">write_cinoutput</tt><big>(</big><em>cio</em><span class="optional">[</span>, <em>properties</em>, <em>properties_array</em>, <em>prefix</em>, <em>int_format</em>, <em>real_format</em>, <em>frame</em>, <em>shuffle</em>, <em>deflate</em>, <em>deflate_level</em>, <em>estr</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.write_cinoutput" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>cio</strong> : <tt class="xref py py-class docutils literal"><span class="pre">CInOutput</span></tt> object</p>
<p><strong>properties</strong> :  input string(len=-1), optional</p>
<p><strong>properties_array</strong> :  input rank-2 array(&#8216;S&#8217;) with bounds (qp_n0,(*)), optional</p>
<p><strong>prefix</strong> :  input string(len=-1), optional</p>
<p><strong>int_format</strong> :  input string(len=-1), optional</p>
<p><strong>real_format</strong> :  input string(len=-1), optional</p>
<p><strong>frame</strong> :  input int, optional</p>
<p><strong>shuffle</strong> :  input int, optional</p>
<p><strong>deflate</strong> :  input int, optional</p>
<p><strong>deflate_level</strong> :  input int, optional</p>
<p><strong>estr</strong> : <tt class="xref py py-class docutils literal"><span class="pre">Extendable_str</span></tt> object, optional</p>
<p class="last"><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">atoms_write_cinoutput</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/CInOutput.f95">libAtoms/CInOutput.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.z_index_to_index">
<tt class="descname">z_index_to_index</tt><big>(</big><em>z</em>, <em>z_index</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.z_index_to_index" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Inverse of atoms_index_to_z_index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z</strong> :  input int</p>
<p><strong>z_index</strong> :  input int</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_index</strong> :  int</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">z_index_to_index</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.zero">
<tt class="descname">zero</tt><big>(</big><span class="optional">[</span><em>indices</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.zero" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Zero data in an Atoms structure &#8212;
this doesn``t finalise it or change it``s size. We zero <tt class="docutils literal"><span class="pre">this.pos</span></tt>,
<tt class="docutils literal"><span class="pre">this.Z</span></tt> and <tt class="docutils literal"><span class="pre">this.species</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>indices</strong> :  input int, optional</p>
<blockquote class="last">
<div><p>Optionally only zero the specified indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">zero</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="method">
<dt id="quippy.atoms.Atoms.zero_angular_momentum">
<tt class="descname">zero_angular_momentum</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.Atoms.zero_angular_momentum" title="Permalink to this definition">Â¶</a></dt>
<dd><p>give the system a rigid body rotation so as to zero the angular momentum about the centre of mass</p>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">zero_angular_momentum</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/DynamicalSystem.f95">libAtoms/DynamicalSystem.f95</a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.arrays">
<tt class="descname">arrays</tt><a class="headerlink" href="#quippy.atoms.Atoms.arrays" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Provides access to ASE arrays, stored in QUIP properties dict</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.calc">
<tt class="descname">calc</tt><a class="headerlink" href="#quippy.atoms.Atoms.calc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculator object.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cell">
<tt class="descname">cell</tt><a class="headerlink" href="#quippy.atoms.Atoms.cell" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Attribute for direct manipulation of the unit cell.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.connect">
<tt class="descname">connect</tt><a class="headerlink" href="#quippy.atoms.Atoms.connect" title="Permalink to this definition">Â¶</a></dt>
<dd><p><a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.constraints">
<tt class="descname">constraints</tt><a class="headerlink" href="#quippy.atoms.Atoms.constraints" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Constraints of the atoms.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cutoff">
<tt class="descname">cutoff</tt><a class="headerlink" href="#quippy.atoms.Atoms.cutoff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>if <tt class="docutils literal"><span class="pre">use_uniform_cutoff</span></tt> is true, cutoff
is the cutoff distance in <img class="math" src="_images/math/61f08a33ffebe94e1e06451ec1142eb65ea18d35.png" alt="\mathrm{\AA}"/>
Otherwise, cutoff is a multiplier
for <tt class="docutils literal"><span class="pre">bond_length(Zi,Zj)</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cutoff_break">
<tt class="descname">cutoff_break</tt><a class="headerlink" href="#quippy.atoms.Atoms.cutoff_break" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Cutoff length for bonds to be considered broken with hysteretic connectivity</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.cutoff_skin">
<tt class="descname">cutoff_skin</tt><a class="headerlink" href="#quippy.atoms.Atoms.cutoff_skin" title="Permalink to this definition">Â¶</a></dt>
<dd><p>If non-zero, increase cutoff by this amount to reduce calc_connect() frequency</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.domain">
<tt class="descname">domain</tt><a class="headerlink" href="#quippy.atoms.Atoms.domain" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Domain decomposition object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.fixed_size">
<tt class="descname">fixed_size</tt><a class="headerlink" href="#quippy.atoms.Atoms.fixed_size" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Can the number of atoms be changed after initialisation?</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.g">
<tt class="descname">g</tt><a class="headerlink" href="#quippy.atoms.Atoms.g" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Inverse lattice (stored for speed)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.hysteretic_connect">
<tt class="descname">hysteretic_connect</tt><a class="headerlink" href="#quippy.atoms.Atoms.hysteretic_connect" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Hysteretic <a class="reference internal" href="connection.html#quippy.atoms.Connection" title="quippy.atoms.Connection"><tt class="xref py py-class docutils literal"><span class="pre">Connection</span></tt></a> object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.indices">
<tt class="descname">indices</tt><a class="headerlink" href="#quippy.atoms.Atoms.indices" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return array of atoms indices</p>
<p>If global <tt class="docutils literal"><span class="pre">fortran_indexing</span></tt> is True, returns FortranArray containing
numbers 1..self.n.  Otherwise, returns a standard numpuy array
containing numbers in range 0..(self.n-1).</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.info">
<tt class="descname">info</tt><a class="headerlink" href="#quippy.atoms.Atoms.info" title="Permalink to this definition">Â¶</a></dt>
<dd><p>ASE info dictionary</p>
<p>Entries are actually stored in QUIP params dictionary.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.lattice">
<tt class="descname">lattice</tt><a class="headerlink" href="#quippy.atoms.Atoms.lattice" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Lattice vectors, as columns:</p>
<div class="math">
<p><img src="_images/math/d8804413e527b5dcda4e679352770e6c2776cbbc.png" alt="\left(
\begin{array}{ccc}
| &amp; | &amp; | \\ \mathbf{a} &amp; \mathbf{b} &amp; \mathbf{c} \\ | &amp; | &amp; | \\ \end{array}
\right)
= \left(
\begin{array}{ccc}
R_{11} &amp; R_{12} &amp; R_{13} \\ R_{21} &amp; R_{22} &amp; R_{23} \\  R_{31} &amp; R_{32} &amp; R_{33} \\ \end{array}
\right)"/></p>
</div><p>i.e. <img class="math" src="_images/math/a7ca8d225c064dae6b3c328bf7acd82b7d8933c9.png" alt="\mathbf{a}"/> = <tt class="docutils literal"><span class="pre">lattice(:,1)</span></tt>, <img class="math" src="_images/math/dd6a0c79ee7e76c8e6f1310a5d171d5b3848b685.png" alt="\mathbf{b}"/> = <tt class="docutils literal"><span class="pre">lattice(:,2)</span></tt> and
<img class="math" src="_images/math/c20b076757f2c84dbfba8d79beeb264442324609.png" alt="\mathbf{c}"/> <tt class="docutils literal"><span class="pre">lattice(:,3)</span></tt>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.n">
<tt class="descname">n</tt><a class="headerlink" href="#quippy.atoms.Atoms.n" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The number of atoms held (including ghost particles)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.nbuffer">
<tt class="descname">nbuffer</tt><a class="headerlink" href="#quippy.atoms.Atoms.nbuffer" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The number of atoms that can be stored in the buffers of this Atoms object</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.ndomain">
<tt class="descname">ndomain</tt><a class="headerlink" href="#quippy.atoms.Atoms.ndomain" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The number of atoms held by the local process (excluding ghost particles)</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.nneightol">
<tt class="descname">nneightol</tt><a class="headerlink" href="#quippy.atoms.Atoms.nneightol" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Count as nearest neighbour if sum of covalent radii
times <tt class="docutils literal"><span class="pre">this.nneightol</span></tt> greater than distance between atoms.
Used in cluster carving.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.numbers">
<tt class="descname">numbers</tt><a class="headerlink" href="#quippy.atoms.Atoms.numbers" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Attribute for direct manipulation of the atomic numbers.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.own_this">
<tt class="descname">own_this</tt><a class="headerlink" href="#quippy.atoms.Atoms.own_this" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Do I own myself?</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.params">
<tt class="descname">params</tt><a class="headerlink" href="#quippy.atoms.Atoms.params" title="Permalink to this definition">Â¶</a></dt>
<dd><p><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> of parameters. Useful for storing data about this
Atoms object, for example the temperature, total energy or
applied strain. The data stored here is automatically saved to
and loaded from XYZ and NetCDF files.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.pbc">
<tt class="descname">pbc</tt><a class="headerlink" href="#quippy.atoms.Atoms.pbc" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Attribute for direct manipulation of the periodic boundary condition flags.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.positions">
<tt class="descname">positions</tt><a class="headerlink" href="#quippy.atoms.Atoms.positions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Attribute for direct manipulation of the positions.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.properties">
<tt class="descname">properties</tt><a class="headerlink" href="#quippy.atoms.Atoms.properties" title="Permalink to this definition">Â¶</a></dt>
<dd><p><a class="reference internal" href="dictionary.html#quippy.dictionary.Dictionary" title="quippy.dictionary.Dictionary"><tt class="xref py py-class docutils literal"><span class="pre">Dictionary</span></tt></a> of atomic properties. A property is an array
of shape (<cite>m</cite>,`n`) where <cite>n</cite> is the number of atoms and <cite>m</cite> is
either one (for scalar properties) or three (vector
properties). Properties can be integer, real, string or logical.
String properties have a fixed length of <tt class="docutils literal"><span class="pre">TABLE_STRING_LENGTH=10</span></tt>
characters.</p>
<p>From Fortran, the following default properties are aliased with
arrays within the Atoms type:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">Z</span></tt> - Atomic numbers, dimension is actually <img class="math" src="_images/math/9b1fafb017a070f395b466fbb58f8b2fd1f1dc1d.png" alt="(N)"/></li>
<li><tt class="docutils literal"><span class="pre">species</span></tt> Names of elements</li>
<li><tt class="docutils literal"><span class="pre">move_mask</span></tt> Atoms with <tt class="docutils literal"><span class="pre">move_mask</span></tt> set to zero are fixed</li>
<li><tt class="docutils literal"><span class="pre">damp_mask</span></tt> Damping is only applied to those atoms with <tt class="docutils literal"><span class="pre">damp_mask</span></tt> set to 1. By default this is set to 1 for all atoms.</li>
<li><tt class="docutils literal"><span class="pre">thermostat_region</span></tt> Which thermostat is applied to each atoms. By default this is set to 1 for all atoms.</li>
<li><tt class="docutils literal"><span class="pre">travel</span></tt> Travel across periodic conditions. <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> integer array. See meth:<cite>map_into_cell</cite> below.</li>
<li><tt class="docutils literal"><span class="pre">pos</span></tt> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array of atomic positions, in <img class="math" src="_images/math/61f08a33ffebe94e1e06451ec1142eb65ea18d35.png" alt="\mathrm{\AA}"/>. Position of atom <img class="math" src="_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> is <tt class="docutils literal"><span class="pre">pos(:,i)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">mass</span></tt> Atomic masses, dimension is <img class="math" src="_images/math/9b1fafb017a070f395b466fbb58f8b2fd1f1dc1d.png" alt="(N)"/></li>
<li><tt class="docutils literal"><span class="pre">velo</span></tt> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of atomic velocities, in <img class="math" src="_images/math/13ecb00172f72fdd977673188080c4f714253f69.png" alt="\mathrm{AA}"/>/fs.</li>
<li><tt class="docutils literal"><span class="pre">acc</span></tt> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of accelerations in <img class="math" src="_images/math/13ecb00172f72fdd977673188080c4f714253f69.png" alt="\mathrm{AA}"/>/fs:math:<cite>^2</cite></li>
<li><tt class="docutils literal"><span class="pre">avgpos</span></tt> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of time-averaged atomic positions.</li>
<li><tt class="docutils literal"><span class="pre">oldpos</span></tt> <img class="math" src="_images/math/596ef05b70bc49dac4a7748d96a29fb48139dd73.png" alt="(3,N)"/> array  of positions of atoms at previous time step.</li>
<li><tt class="docutils literal"><span class="pre">avg_ke</span></tt> Time-averaged atomic kinetic energy</li>
</ul>
</div></blockquote>
<p>Custom properties are most conveniently accessed by assign a pointer to
them with the <tt class="xref py py-meth docutils literal"><span class="pre">assign_pointer()</span></tt> routines.</p>
<p>From Python, each property is automatically visible as a
array attribute of the <a class="reference internal" href="#quippy.atoms.Atoms" title="quippy.atoms.Atoms"><tt class="xref py py-class docutils literal"><span class="pre">Atoms</span></tt></a> object,
for example the atomic positions are stored in a real vector
property called <cite>pos</cite>, and can be accessed as <tt class="docutils literal"><span class="pre">at.pos</span></tt>.</p>
<p>Properties can be added with the <a class="reference internal" href="#quippy.atoms.Atoms.add_property" title="quippy.atoms.Atoms.add_property"><tt class="xref py py-meth docutils literal"><span class="pre">add_property()</span></tt></a> method and
removed with <a class="reference internal" href="#quippy.atoms.Atoms.remove_property" title="quippy.atoms.Atoms.remove_property"><tt class="xref py py-meth docutils literal"><span class="pre">remove_property()</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.ref_count">
<tt class="descname">ref_count</tt><a class="headerlink" href="#quippy.atoms.Atoms.ref_count" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Reference counter</p>
</dd></dl>

<dl class="attribute">
<dt id="quippy.atoms.Atoms.use_uniform_cutoff">
<tt class="descname">use_uniform_cutoff</tt><a class="headerlink" href="#quippy.atoms.Atoms.use_uniform_cutoff" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Rather than covalent radii &#8212;
default is variable cutoff.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="quippy.atoms.make_lattice">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">make_lattice</tt><big>(</big><em>a</em><span class="optional">[</span>, <em>b</em>, <em>c</em>, <em>alpha</em>, <em>beta</em>, <em>gamma</em>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.make_lattice" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Make a matrix of lattice vectors from the lengths <tt class="docutils literal"><span class="pre">a</span></tt>,``b``,``c``
and the angles <tt class="docutils literal"><span class="pre">alpha</span></tt>, <tt class="docutils literal"><span class="pre">beta</span></tt> and <tt class="docutils literal"><span class="pre">gamma</span></tt>.
One length must be supplied. Any missing angle is assumed to be 90 degrees
and any missing length is assumed to be <tt class="docutils literal"><span class="pre">a</span></tt>.
The vectors are created in a right-handed order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>a</strong> :  input float</p>
<p><strong>b</strong> :  input float, optional</p>
<p><strong>c</strong> :  input float, optional</p>
<p><strong>alpha</strong> :  input float, optional</p>
<p><strong>beta</strong> :  input float, optional</p>
<p><strong>gamma</strong> :  input float, optional</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_lattice</strong> :  rank-2 array(&#8216;d&#8217;) with bounds (3,3)</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">make_lattice</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.get_lattice_params">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">get_lattice_params</tt><big>(</big><em>lattice</em><big>)</big><a class="reference internal" href="_modules/quippy/atoms.html#get_lattice_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#quippy.atoms.get_lattice_params" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wrapper around Fortran <tt class="xref py py-func docutils literal"><span class="pre">get_lattice_params_()</span></tt></p>
<p>Returns parameters of <cite>lattice</cite> as 6-tuple (a,b,c,alpha,beta,gamma).</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.bond_length">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">bond_length</tt><big>(</big><em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#quippy.atoms.bond_length" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Returns the sum of the covalent radii of two atoms</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_bond_length</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">bond_length</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.termination_bond_rescale">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">termination_bond_rescale</tt><big>(</big><em>z1</em>, <em>z2</em><big>)</big><a class="headerlink" href="#quippy.atoms.termination_bond_rescale" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Calculates the rescale ratio of a Z1&#8211;H bond
generate from a Z1&#8211;Z2 bond.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>z1</strong> :  input int</p>
<p><strong>z2</strong> :  input int</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>ret_termination_bond_rescale</strong> :  float</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">termination_bond_rescale</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.cell_volume">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">cell_volume</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.cell_volume" title="Permalink to this definition">Â¶</a></dt>
<dd><p>calculate volume of unit cell</p>
<p>Routine is wrapper around Fortran interface <tt class="docutils literal"><span class="pre">cell_volume</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">cell_volume</tt><big>(</big><em>lattice</em><big>)</big></dt>
<dd><p>Returns the (unsigned) volume of the simulation cell of lattice</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ret_lattice_cell_volume</strong> &#8211;  float</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">lattice_cell_volume</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.map_into_cell">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">map_into_cell</tt><big>(</big><em>*args</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#quippy.atoms.map_into_cell" title="Permalink to this definition">Â¶</a></dt>
<dd><dl class="docutils">
<dt>Map atomic positions into the unit cell so that lattice</dt>
<dd>coordinates satisfy $-0.5 le t_x,t_y,t_z &lt; 0.5$</dd>
</dl>
<p>Routine is wrapper around Fortran interface <tt class="docutils literal"><span class="pre">map_into_cell</span></tt> containing multiple routines:</p>
<blockquote>
<div><dl class="function">
<dt>
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">map_into_cell</tt><big>(</big><em>pos</em>, <em>lattice</em>, <em>g</em><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>in/output rank-2 array(&#8216;d&#8217;) with bounds (qp_n0,qp_n1)</em>) &#8211; </li>
<li><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>g</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">array_map_into_cell</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">map_into_cell</tt><big>(</big><em>pos</em>, <em>lattice</em>, <em>g</em><span class="optional">[</span>, <em>shift</em>, <em>mapped</em><span class="optional">]</span><big>)</big></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pos</strong> (<em>in/output rank-1 array(&#8216;d&#8217;) with bounds (3)</em>) &#8211; </li>
<li><strong>lattice</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>g</strong> (<em>input rank-2 array(&#8216;d&#8217;) with bounds (3,3)</em>) &#8211; </li>
<li><strong>shift</strong> (<em>in/output rank-1 array(&#8216;i&#8217;) with bounds (3), optional</em>) &#8211; </li>
<li><strong>mapped</strong> (<em>in/output rank-0 array(int,&#8217;i&#8217;), optional</em>) &#8211; </li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">vec_map_into_cell</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="quippy.atoms.parse_atom_mask">
<tt class="descclassname">quippy.atoms.</tt><tt class="descname">parse_atom_mask</tt><big>(</big><em>mask_in</em><span class="optional">[</span>, <em>error</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#quippy.atoms.parse_atom_mask" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Parses an atom_mask, which is string consisting of the <tt class="docutils literal"><span class="pre">&#64;</span></tt> symbol followed by a comma separated
list of indices or ranges into a table containing all the indices it represents.
E.g. <tt class="docutils literal"><span class="pre">&#64;1,37-39,54,99-102</span></tt> is expanded to a table with 1, 37, 38, 39, 54, 99, 100,
101, 102 as its first integer column. There must be no spaces in the mask.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>mask_in</strong> :  input string(len=-1)</p>
<p><strong>error</strong> :  in/output rank-0 array(int,&#8217;i&#8217;), optional</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>atom_indices</strong> : <a class="reference internal" href="table.html#quippy.table.Table" title="quippy.table.Table"><tt class="xref py py-class docutils literal"><span class="pre">Table</span></tt></a> object</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>Routine is wrapper around Fortran routine <tt class="docutils literal"><span class="pre">parse_atom_mask</span></tt> defined in file <a class="reference external" href="https://github.com/libAtoms/QUIP/blob/public/libAtoms/Atoms_types.f95">libAtoms/Atoms_types.f95</a>.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="quippy.html" title="Quippy library reference"
             >previous</a> |</li>
        <li><a href="index.html">quippy  documentation</a> &raquo;</li>
          <li><a href="quippy.html" >Quippy library reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2013, James Kermode.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>